<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>iconv.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">iconv.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/* Copyright (C) 2000-2006 Free Software Foundation, Inc.
   This file is part of the GNU LIBICONV Library.

   The GNU LIBICONV Library is free software; you can redistribute it
   and/or modify it under the terms of the GNU Library General Public
   License as published by the Free Software Foundation; either version 2
   of the License, or (at your option) any later version.

   The GNU LIBICONV Library is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Library General Public
   License along with the GNU LIBICONV Library; see the file COPYING.LIB.
   If not, write to the Free Software Foundation, Inc., 51 Franklin Street,
   Fifth Floor, Boston, MA 02110-1301, USA.  */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;config.h&quot;</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">ICONV_CONST</span>
# <span class="enscript-reference">define</span> <span class="enscript-variable-name">ICONV_CONST</span> const
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;limits.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stddef.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;iconv.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;errno.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HAVE_LOCALE_H</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;locale.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;fcntl.h&gt;</span>

<span class="enscript-comment">/* Ensure that iconv_no_i18n does not depend on libintl.  */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NO_I18N</span>
# <span class="enscript-reference">undef</span> <span class="enscript-variable-name">ENABLE_NLS</span>
# <span class="enscript-reference">undef</span> <span class="enscript-variable-name">ENABLE_RELOCATABLE</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;binary-io.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;exit.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;progname.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;relocatable.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;xalloc.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;uniwidth.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;cjk.h&quot;</span>

<span class="enscript-comment">/* Ensure that iconv_no_i18n does not depend on libintl.  */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NO_I18N</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdarg.h&gt;</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">error</span> (<span class="enscript-type">int</span> status, <span class="enscript-type">int</span> errnum, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *message, ...)
{
  va_list args;

  fflush(stdout);
  fprintf(stderr,<span class="enscript-string">&quot;%s: &quot;</span>,program_name);
  va_start(args,message);
  vfprintf(stderr,message,args);
  va_end(args);
  <span class="enscript-keyword">if</span> (errnum) {
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *s = strerror(errnum);
    <span class="enscript-keyword">if</span> (s == NULL)
      s = <span class="enscript-string">&quot;Unknown system error&quot;</span>;
  }
  putc(<span class="enscript-string">'\n'</span>,stderr);
  fflush(stderr);
  <span class="enscript-keyword">if</span> (status)
    exit(status);
}
#<span class="enscript-reference">else</span>
# <span class="enscript-reference">include</span> <span class="enscript-string">&quot;error.h&quot;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;gettext.h&quot;</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">_</span>(str) gettext(str)

<span class="enscript-comment">/* Ensure that iconv_no_i18n does not depend on libintl.  */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NO_I18N</span>
# <span class="enscript-reference">define</span> <span class="enscript-variable-name">xmalloc</span> malloc
# <span class="enscript-reference">define</span> <span class="enscript-variable-name">xalloc_die</span> abort
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* Locale independent test for a decimal digit.
   Argument can be  'char' or 'unsigned char'.  (Whereas the argument of
   &lt;ctype.h&gt; isdigit must be an 'unsigned char'.)  */</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">isdigit</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">isdigit</span>(c) ((unsigned int) ((c) - <span class="enscript-string">'0'</span>) &lt; 10)

<span class="enscript-comment">/* Locale independent test for a printable character.
   Argument can be  'char' or 'unsigned char'.  (Whereas the argument of
   &lt;ctype.h&gt; isdigit must be an 'unsigned char'.)  */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">c_isprint</span>(c) ((c) &gt;= <span class="enscript-string">' '</span> &amp;&amp; (c) &lt;= <span class="enscript-string">'~'</span>)

<span class="enscript-comment">/* ========================================================================= */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> discard_unconvertible = 0;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> silent = 0;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">usage</span> (<span class="enscript-type">int</span> exitcode)
{
  <span class="enscript-keyword">if</span> (exitcode != 0) {
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>* helpstring1 =
      _(<span class="enscript-string">&quot;Usage: iconv [-c] [-s] [-f fromcode] [-t tocode] [file ...]&quot;</span>);
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>* helpstring2 =
      _(<span class="enscript-string">&quot;or:    iconv -l&quot;</span>);
    fprintf(stderr, <span class="enscript-string">&quot;%s\n%s\n&quot;</span>, helpstring1, helpstring2);
    fprintf(stderr, _(<span class="enscript-string">&quot;Try `%s --help' for more information.\n&quot;</span>), program_name);
  } <span class="enscript-keyword">else</span> {
    <span class="enscript-comment">/* xgettext: no-wrap */</span>
    printf(_(<span class="enscript-string">&quot;\
Usage: %s [OPTION...] [-f ENCODING] [-t ENCODING] [INPUTFILE...]\n&quot;</span>),
           program_name);
    <span class="enscript-comment">/* xgettext: no-wrap */</span>
    printf(_(<span class="enscript-string">&quot;\
or:    %s -l\n&quot;</span>),
           program_name);
    printf(<span class="enscript-string">&quot;\n&quot;</span>);
    <span class="enscript-comment">/* xgettext: no-wrap */</span>
    printf(_(<span class="enscript-string">&quot;\
Converts text from one encoding to another encoding.\n&quot;</span>));
    printf(<span class="enscript-string">&quot;\n&quot;</span>);
    <span class="enscript-comment">/* xgettext: no-wrap */</span>
    printf(_(<span class="enscript-string">&quot;\
Options controlling the input and output format:\n&quot;</span>));
    <span class="enscript-comment">/* xgettext: no-wrap */</span>
    printf(_(<span class="enscript-string">&quot;\
  -f ENCODING, --from-code=ENCODING\n\
                              the encoding of the input\n&quot;</span>));
    <span class="enscript-comment">/* xgettext: no-wrap */</span>
    printf(_(<span class="enscript-string">&quot;\
  -t ENCODING, --to-code=ENCODING\n\
                              the encoding of the output\n&quot;</span>));
    printf(<span class="enscript-string">&quot;\n&quot;</span>);
    <span class="enscript-comment">/* xgettext: no-wrap */</span>
    printf(_(<span class="enscript-string">&quot;\
Options controlling conversion problems:\n&quot;</span>));
    <span class="enscript-comment">/* xgettext: no-wrap */</span>
    printf(_(<span class="enscript-string">&quot;\
  -c                          discard unconvertible characters\n&quot;</span>));
    <span class="enscript-comment">/* xgettext: no-wrap */</span>
    printf(_(<span class="enscript-string">&quot;\
  --unicode-subst=FORMATSTRING\n\
                              substitution for unconvertible Unicode characters\n&quot;</span>));
    <span class="enscript-comment">/* xgettext: no-wrap */</span>
    printf(_(<span class="enscript-string">&quot;\
  --byte-subst=FORMATSTRING   substitution for unconvertible bytes\n&quot;</span>));
    <span class="enscript-comment">/* xgettext: no-wrap */</span>
    printf(_(<span class="enscript-string">&quot;\
  --widechar-subst=FORMATSTRING\n\
                              substitution for unconvertible wide characters\n&quot;</span>));
    printf(<span class="enscript-string">&quot;\n&quot;</span>);
    <span class="enscript-comment">/* xgettext: no-wrap */</span>
    printf(_(<span class="enscript-string">&quot;\
Options controlling error output:\n&quot;</span>));
    <span class="enscript-comment">/* xgettext: no-wrap */</span>
    printf(_(<span class="enscript-string">&quot;\
  -s, --silent                suppress error messages about conversion problems\n&quot;</span>));
    printf(<span class="enscript-string">&quot;\n&quot;</span>);
    <span class="enscript-comment">/* xgettext: no-wrap */</span>
    printf(_(<span class="enscript-string">&quot;\
Informative output:\n&quot;</span>));
    <span class="enscript-comment">/* xgettext: no-wrap */</span>
    printf(_(<span class="enscript-string">&quot;\
  -l, --list                  list the supported encodings\n&quot;</span>));
    <span class="enscript-comment">/* xgettext: no-wrap */</span>
    printf(_(<span class="enscript-string">&quot;\
  --help                      display this help and exit\n&quot;</span>));
    <span class="enscript-comment">/* xgettext: no-wrap */</span>
    printf(_(<span class="enscript-string">&quot;\
  --version                   output version information and exit\n&quot;</span>));
    printf(<span class="enscript-string">&quot;\n&quot;</span>);
    fputs(_(<span class="enscript-string">&quot;Report bugs to &lt;<a href="mailto:bug-gnu-libiconv@gnu.org">bug-gnu-libiconv@gnu.org</a>&gt;.\n&quot;</span>),stdout);
  }
  exit(exitcode);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">print_version</span> (<span class="enscript-type">void</span>)
{
  printf(<span class="enscript-string">&quot;iconv (GNU libiconv %d.%d)\n&quot;</span>,
         _libiconv_version &gt;&gt; 8, _libiconv_version &amp; 0xff);
  printf(<span class="enscript-string">&quot;Copyright (C) %s Free Software Foundation, Inc.\n&quot;</span>, <span class="enscript-string">&quot;2000-2006&quot;</span>);
  printf(_(<span class="enscript-string">&quot;\
This is free software; see the source for copying conditions.  There is NO\n\
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n&quot;</span>));
  printf(_(<span class="enscript-string">&quot;Written by %s.\n&quot;</span>),<span class="enscript-string">&quot;Bruno Haible&quot;</span>);
  exit(EXIT_SUCCESS);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">print_one</span> (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> namescount, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * <span class="enscript-type">const</span> * names,
                      <span class="enscript-type">void</span>* data)
{
  <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;
  (<span class="enscript-type">void</span>)data;
  <span class="enscript-keyword">for</span> (i = 0; i &lt; namescount; i++) {
    <span class="enscript-keyword">if</span> (i &gt; 0)
      putc(<span class="enscript-string">' '</span>,stdout);
    fputs(names[i],stdout);
  }
  putc(<span class="enscript-string">'\n'</span>,stdout);
  <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/* ========================================================================= */</span>

<span class="enscript-comment">/* Line number and column position. */</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> line;
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> column;
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span>* cjkcode;
<span class="enscript-comment">/* Update the line number and column position after a character was
   successfully converted. */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">update_line_column</span> (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> uc, <span class="enscript-type">void</span>* data)
{
  <span class="enscript-keyword">if</span> (uc == 0x000A) {
    line++;
    column = 0;
  } <span class="enscript-keyword">else</span> {
    <span class="enscript-type">int</span> width = uc_width(uc, cjkcode);
    <span class="enscript-keyword">if</span> (width &gt;= 0)
      column += width;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (uc == 0x0009)
      column += 8 - (column % 8);
  }
}

<span class="enscript-comment">/* ========================================================================= */</span>

<span class="enscript-comment">/* Production of placeholder strings as fallback for unconvertible
   characters. */</span>

<span class="enscript-comment">/* Check that the argument is a format string taking either no argument
   or exactly one unsigned integer argument. Returns the maximum output
   size of the format string. */</span>
<span class="enscript-type">static</span> size_t <span class="enscript-function-name">check_subst_formatstring</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *format, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *param_name)
{
  <span class="enscript-comment">/* C format strings are described in POSIX (IEEE P1003.1 2001), section
     XSH 3 fprintf().  See also Linux fprintf(3) manual page.
     For simplicity, we don't accept
       - the '%m$' reordering syntax,
       - the 'I' flag,
       - width specifications referring to an argument,
       - precision specifications referring to an argument,
       - size specifiers,
       - format specifiers other than 'o', 'u', 'x', 'X'.
     What remains?
     A directive
       - starts with '%',
       - is optionally followed by any of the characters '#', '0', '-', ' ',
         '+', &quot;'&quot;, each of which acts as a flag,
       - is optionally followed by a width specification: a nonempty digit
         sequence,
       - is optionally followed by '.' and a precision specification: a
         nonempty digit sequence,
       - is finished by a specifier
         - '%', that needs no argument,
         - 'o', 'u', 'x', 'X', that need an unsigned integer argument.
   */</span>
  size_t maxsize = 0;
  <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> unnumbered_arg_count = 0;

  <span class="enscript-keyword">for</span> (; *format != <span class="enscript-string">'\0'</span>;) {
    <span class="enscript-keyword">if</span> (*format++ == <span class="enscript-string">'%'</span>) {
      <span class="enscript-comment">/* A directive. */</span>
      <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> width = 0;
      <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> precision = 0;
      <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> length;
      <span class="enscript-comment">/* Parse flags. */</span>
      <span class="enscript-keyword">for</span> (;;) {
        <span class="enscript-keyword">if</span> (*format == <span class="enscript-string">' '</span> || *format == <span class="enscript-string">'+'</span> || *format == <span class="enscript-string">'-'</span>
            || *format == <span class="enscript-string">'#'</span> || *format == <span class="enscript-string">'0'</span> || *format == <span class="enscript-string">'\''</span>)
          format++;
        <span class="enscript-keyword">else</span>
          <span class="enscript-keyword">break</span>;
      }
      <span class="enscript-comment">/* Parse width. */</span>
      <span class="enscript-keyword">if</span> (*format == <span class="enscript-string">'*'</span>)
        error(EXIT_FAILURE,0,_(<span class="enscript-string">&quot;%s argument: A format directive with a variable width is not allowed here.&quot;</span>),param_name);
      <span class="enscript-keyword">if</span> (isdigit (*format)) {
        <span class="enscript-keyword">do</span> {
          width = 10*width + (*format - <span class="enscript-string">'0'</span>);
          format++;
        } <span class="enscript-keyword">while</span> (isdigit (*format));
      }
      <span class="enscript-comment">/* Parse precision. */</span>
      <span class="enscript-keyword">if</span> (*format == <span class="enscript-string">'.'</span>) {
        format++;
        <span class="enscript-keyword">if</span> (*format == <span class="enscript-string">'*'</span>)
          error(EXIT_FAILURE,0,_(<span class="enscript-string">&quot;%s argument: A format directive with a variable precision is not allowed here.&quot;</span>),param_name);
        <span class="enscript-keyword">if</span> (isdigit (*format)) {
          <span class="enscript-keyword">do</span> {
            precision = 10*precision + (*format - <span class="enscript-string">'0'</span>);
            format++;
          } <span class="enscript-keyword">while</span> (isdigit (*format));
        }
      }
      <span class="enscript-comment">/* Parse size. */</span>
      <span class="enscript-keyword">switch</span> (*format) {
        <span class="enscript-keyword">case</span> <span class="enscript-string">'h'</span>: <span class="enscript-keyword">case</span> <span class="enscript-string">'l'</span>: <span class="enscript-keyword">case</span> <span class="enscript-string">'L'</span>: <span class="enscript-keyword">case</span> <span class="enscript-string">'q'</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-string">'j'</span>: <span class="enscript-keyword">case</span> <span class="enscript-string">'z'</span>: <span class="enscript-keyword">case</span> <span class="enscript-string">'Z'</span>: <span class="enscript-keyword">case</span> <span class="enscript-string">'t'</span>:
          error(EXIT_FAILURE,0,_(<span class="enscript-string">&quot;%s argument: A format directive with a size is not allowed here.&quot;</span>),param_name);
      }
      <span class="enscript-comment">/* Parse end of directive. */</span>
      <span class="enscript-keyword">switch</span> (*format) {
        <span class="enscript-keyword">case</span> <span class="enscript-string">'%'</span>:
          length = 1;
          <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-string">'u'</span>: <span class="enscript-keyword">case</span> <span class="enscript-string">'o'</span>: <span class="enscript-keyword">case</span> <span class="enscript-string">'x'</span>: <span class="enscript-keyword">case</span> <span class="enscript-string">'X'</span>:
          <span class="enscript-keyword">if</span> (*format == <span class="enscript-string">'u'</span>) {
            length = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) (<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) * CHAR_BIT
                                     * 0.30103 <span class="enscript-comment">/* binary -&gt; decimal */</span>
                                    )
                     + 1; <span class="enscript-comment">/* turn floor into ceil */</span>
            <span class="enscript-keyword">if</span> (length &lt; precision)
              length = precision;
            length *= 2; <span class="enscript-comment">/* estimate for FLAG_GROUP */</span>
            length += 1; <span class="enscript-comment">/* account for leading sign */</span>
          } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (*format == <span class="enscript-string">'o'</span>) {
            length = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) (<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) * CHAR_BIT
                                     * 0.333334 <span class="enscript-comment">/* binary -&gt; octal */</span>
                                    )
                     + 1; <span class="enscript-comment">/* turn floor into ceil */</span>
            <span class="enscript-keyword">if</span> (length &lt; precision)
              length = precision;
            length += 1; <span class="enscript-comment">/* account for leading sign */</span>
          } <span class="enscript-keyword">else</span> { <span class="enscript-comment">/* 'x', 'X' */</span>
            length = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) (<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) * CHAR_BIT
                                     * 0.25 <span class="enscript-comment">/* binary -&gt; hexadecimal */</span>
                                    )
                     + 1; <span class="enscript-comment">/* turn floor into ceil */</span>
            <span class="enscript-keyword">if</span> (length &lt; precision)
              length = precision;
            length += 2; <span class="enscript-comment">/* account for leading sign or alternate form */</span>
          }
          unnumbered_arg_count++;
          <span class="enscript-keyword">break</span>;
        <span class="enscript-reference">default</span>:
          <span class="enscript-keyword">if</span> (*format == <span class="enscript-string">'\0'</span>)
            error(EXIT_FAILURE,0,_(<span class="enscript-string">&quot;%s argument: The string ends in the middle of a directive.&quot;</span>),param_name);
          <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (c_isprint(*format))
            error(EXIT_FAILURE,0,_(<span class="enscript-string">&quot;%s argument: The character '%c' is not a valid conversion specifier.&quot;</span>),param_name,*format);
          <span class="enscript-keyword">else</span>
            error(EXIT_FAILURE,0,_(<span class="enscript-string">&quot;%s argument: The character that terminates the format directive is not a valid conversion specifier.&quot;</span>),param_name);
          abort(); <span class="enscript-comment">/*NOTREACHED*/</span>
      }
      format++;
      <span class="enscript-keyword">if</span> (length &lt; width)
        length = width;
      maxsize += length;
    } <span class="enscript-keyword">else</span>
      maxsize++;
  }
  <span class="enscript-keyword">if</span> (unnumbered_arg_count &gt; 1)
    error(EXIT_FAILURE,0,ngettext(<span class="enscript-string">&quot;%s argument: The format string consumes more than one argument: %u argument.&quot;</span>,
                                  <span class="enscript-string">&quot;%s argument: The format string consumes more than one argument: %u arguments.&quot;</span>,
                                  unnumbered_arg_count),
                         param_name,unnumbered_arg_count);
  <span class="enscript-keyword">return</span> maxsize;
}

<span class="enscript-comment">/* Format strings. */</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span>* ilseq_byte_subst;
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span>* ilseq_wchar_subst;
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span>* ilseq_unicode_subst;

<span class="enscript-comment">/* Maximum result size for each format string. */</span>
<span class="enscript-type">static</span> size_t ilseq_byte_subst_size;
<span class="enscript-type">static</span> size_t ilseq_wchar_subst_size;
<span class="enscript-type">static</span> size_t ilseq_unicode_subst_size;

<span class="enscript-comment">/* Buffer of size ilseq_byte_subst_size+1. */</span>
<span class="enscript-type">static</span> <span class="enscript-type">char</span>* ilseq_byte_subst_buffer;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HAVE_WCHAR_T</span>
<span class="enscript-comment">/* Buffer of size ilseq_wchar_subst_size+1. */</span>
<span class="enscript-type">static</span> <span class="enscript-type">char</span>* ilseq_wchar_subst_buffer;
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/* Buffer of size ilseq_unicode_subst_size+1. */</span>
<span class="enscript-type">static</span> <span class="enscript-type">char</span>* ilseq_unicode_subst_buffer;

<span class="enscript-comment">/* Auxiliary variables for subst_mb_to_uc_fallback. */</span>
<span class="enscript-comment">/* Converter from locale encoding to UCS-4. */</span>
<span class="enscript-type">static</span> iconv_t subst_mb_to_uc_cd;
<span class="enscript-comment">/* Buffer of size ilseq_byte_subst_size. */</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>* subst_mb_to_uc_temp_buffer;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> subst_mb_to_uc_fallback
            (<span class="enscript-type">const</span> <span class="enscript-type">char</span>* inbuf, size_t inbufsize,
             <span class="enscript-type">void</span> (*write_replacement) (<span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *buf, size_t buflen,
                                        <span class="enscript-type">void</span>* callback_arg),
             <span class="enscript-type">void</span>* callback_arg,
             <span class="enscript-type">void</span>* data)
{
  <span class="enscript-keyword">for</span> (; inbufsize &gt; 0; inbuf++, inbufsize--) {
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>* inptr;
    size_t inbytesleft;
    <span class="enscript-type">char</span>* outptr;
    size_t outbytesleft;
    sprintf(ilseq_byte_subst_buffer,
            ilseq_byte_subst, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>)*inbuf);
    inptr = ilseq_byte_subst_buffer;
    inbytesleft = strlen(ilseq_byte_subst_buffer);
    outptr = (<span class="enscript-type">char</span>*)subst_mb_to_uc_temp_buffer;
    outbytesleft = ilseq_byte_subst_size*<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);
    iconv(subst_mb_to_uc_cd,NULL,NULL,NULL,NULL);
    <span class="enscript-keyword">if</span> (iconv(subst_mb_to_uc_cd, (ICONV_CONST <span class="enscript-type">char</span>**)&amp;inptr,&amp;inbytesleft, &amp;outptr,&amp;outbytesleft)
        == (size_t)(-1)
        || iconv(subst_mb_to_uc_cd, NULL,NULL, &amp;outptr,&amp;outbytesleft)
           == (size_t)(-1))
      error(EXIT_FAILURE,0,_(<span class="enscript-string">&quot;cannot convert byte substitution to Unicode: %s&quot;</span>),ilseq_byte_subst_buffer);
    <span class="enscript-keyword">if</span> (!(outbytesleft%<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) == 0))
      abort();
    write_replacement(subst_mb_to_uc_temp_buffer,
                      ilseq_byte_subst_size-(outbytesleft/<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)),
                      callback_arg);
  }
}

<span class="enscript-comment">/* Auxiliary variables for subst_uc_to_mb_fallback. */</span>
<span class="enscript-comment">/* Converter from locale encoding to target encoding. */</span>
<span class="enscript-type">static</span> iconv_t subst_uc_to_mb_cd;
<span class="enscript-comment">/* Buffer of size ilseq_unicode_subst_size*4. */</span>
<span class="enscript-type">static</span> <span class="enscript-type">char</span>* subst_uc_to_mb_temp_buffer;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> subst_uc_to_mb_fallback
            (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> code,
             <span class="enscript-type">void</span> (*write_replacement) (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *buf, size_t buflen,
                                        <span class="enscript-type">void</span>* callback_arg),
             <span class="enscript-type">void</span>* callback_arg,
             <span class="enscript-type">void</span>* data)
{
  <span class="enscript-type">const</span> <span class="enscript-type">char</span>* inptr;
  size_t inbytesleft;
  <span class="enscript-type">char</span>* outptr;
  size_t outbytesleft;
  sprintf(ilseq_unicode_subst_buffer, ilseq_unicode_subst, code);
  inptr = ilseq_unicode_subst_buffer;
  inbytesleft = strlen(ilseq_unicode_subst_buffer);
  outptr = subst_uc_to_mb_temp_buffer;
  outbytesleft = ilseq_unicode_subst_size*4;
  iconv(subst_uc_to_mb_cd,NULL,NULL,NULL,NULL);
  <span class="enscript-keyword">if</span> (iconv(subst_uc_to_mb_cd, (ICONV_CONST <span class="enscript-type">char</span>**)&amp;inptr,&amp;inbytesleft, &amp;outptr,&amp;outbytesleft)
      == (size_t)(-1)
      || iconv(subst_uc_to_mb_cd, NULL,NULL, &amp;outptr,&amp;outbytesleft)
         == (size_t)(-1))
    error(EXIT_FAILURE,0,_(<span class="enscript-string">&quot;cannot convert unicode substitution to target encoding: %s&quot;</span>),ilseq_unicode_subst_buffer);
  write_replacement(subst_uc_to_mb_temp_buffer,
                    ilseq_unicode_subst_size*4-outbytesleft,
                    callback_arg);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HAVE_WCHAR_T</span>

<span class="enscript-comment">/* Auxiliary variables for subst_mb_to_wc_fallback. */</span>
<span class="enscript-comment">/* Converter from locale encoding to wchar_t. */</span>
<span class="enscript-type">static</span> iconv_t subst_mb_to_wc_cd;
<span class="enscript-comment">/* Buffer of size ilseq_byte_subst_size. */</span>
<span class="enscript-type">static</span> wchar_t* subst_mb_to_wc_temp_buffer;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> subst_mb_to_wc_fallback
            (<span class="enscript-type">const</span> <span class="enscript-type">char</span>* inbuf, size_t inbufsize,
             <span class="enscript-type">void</span> (*write_replacement) (<span class="enscript-type">const</span> wchar_t *buf, size_t buflen,
                                        <span class="enscript-type">void</span>* callback_arg),
             <span class="enscript-type">void</span>* callback_arg,
             <span class="enscript-type">void</span>* data)
{
  <span class="enscript-keyword">for</span> (; inbufsize &gt; 0; inbuf++, inbufsize--) {
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>* inptr;
    size_t inbytesleft;
    <span class="enscript-type">char</span>* outptr;
    size_t outbytesleft;
    sprintf(ilseq_byte_subst_buffer,
            ilseq_byte_subst, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>)*inbuf);
    inptr = ilseq_byte_subst_buffer;
    inbytesleft = strlen(ilseq_byte_subst_buffer);
    outptr = (<span class="enscript-type">char</span>*)subst_mb_to_wc_temp_buffer;
    outbytesleft = ilseq_byte_subst_size*<span class="enscript-keyword">sizeof</span>(wchar_t);
    iconv(subst_mb_to_wc_cd,NULL,NULL,NULL,NULL);
    <span class="enscript-keyword">if</span> (iconv(subst_mb_to_wc_cd, (ICONV_CONST <span class="enscript-type">char</span>**)&amp;inptr,&amp;inbytesleft, &amp;outptr,&amp;outbytesleft)
        == (size_t)(-1)
        || iconv(subst_mb_to_wc_cd, NULL,NULL, &amp;outptr,&amp;outbytesleft)
           == (size_t)(-1))
      error(EXIT_FAILURE,0,_(<span class="enscript-string">&quot;cannot convert byte substitution to wide string: %s&quot;</span>),ilseq_byte_subst_buffer);
    <span class="enscript-keyword">if</span> (!(outbytesleft%<span class="enscript-keyword">sizeof</span>(wchar_t) == 0))
      abort();
    write_replacement(subst_mb_to_wc_temp_buffer,
                      ilseq_byte_subst_size-(outbytesleft/<span class="enscript-keyword">sizeof</span>(wchar_t)),
                      callback_arg);
  }
}

<span class="enscript-comment">/* Auxiliary variables for subst_wc_to_mb_fallback. */</span>
<span class="enscript-comment">/* Converter from locale encoding to target encoding. */</span>
<span class="enscript-type">static</span> iconv_t subst_wc_to_mb_cd;
<span class="enscript-comment">/* Buffer of size ilseq_wchar_subst_size*4.
   Hardcode factor 4, because MB_LEN_MAX is not reliable on some platforms. */</span>
<span class="enscript-type">static</span> <span class="enscript-type">char</span>* subst_wc_to_mb_temp_buffer;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> subst_wc_to_mb_fallback
            (wchar_t code,
             <span class="enscript-type">void</span> (*write_replacement) (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *buf, size_t buflen,
                                        <span class="enscript-type">void</span>* callback_arg),
             <span class="enscript-type">void</span>* callback_arg,
             <span class="enscript-type">void</span>* data)
{
  <span class="enscript-type">const</span> <span class="enscript-type">char</span>* inptr;
  size_t inbytesleft;
  <span class="enscript-type">char</span>* outptr;
  size_t outbytesleft;
  sprintf(ilseq_wchar_subst_buffer, ilseq_wchar_subst, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) code);
  inptr = ilseq_wchar_subst_buffer;
  inbytesleft = strlen(ilseq_wchar_subst_buffer);
  outptr = subst_wc_to_mb_temp_buffer;
  outbytesleft = ilseq_wchar_subst_size*4;
  iconv(subst_wc_to_mb_cd,NULL,NULL,NULL,NULL);
  <span class="enscript-keyword">if</span> (iconv(subst_wc_to_mb_cd, (ICONV_CONST <span class="enscript-type">char</span>**)&amp;inptr,&amp;inbytesleft, &amp;outptr,&amp;outbytesleft)
      == (size_t)(-1)
      || iconv(subst_wc_to_mb_cd, NULL,NULL, &amp;outptr,&amp;outbytesleft)
         == (size_t)(-1))
    error(EXIT_FAILURE,0,_(<span class="enscript-string">&quot;cannot convert widechar substitution to target encoding: %s&quot;</span>),ilseq_wchar_subst_buffer);
  write_replacement(subst_wc_to_mb_temp_buffer,
                    ilseq_wchar_subst_size*4-outbytesleft,
                    callback_arg);
}

#<span class="enscript-reference">else</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">subst_mb_to_wc_fallback</span> NULL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">subst_wc_to_mb_fallback</span> NULL

#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* Auxiliary variables for subst_mb_to_mb_fallback. */</span>
<span class="enscript-comment">/* Converter from locale encoding to target encoding. */</span>
<span class="enscript-type">static</span> iconv_t subst_mb_to_mb_cd;
<span class="enscript-comment">/* Buffer of size ilseq_byte_subst_size*4. */</span>
<span class="enscript-type">static</span> <span class="enscript-type">char</span>* subst_mb_to_mb_temp_buffer;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">subst_mb_to_mb_fallback</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span>* inbuf, size_t inbufsize)
{
  <span class="enscript-keyword">for</span> (; inbufsize &gt; 0; inbuf++, inbufsize--) {
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>* inptr;
    size_t inbytesleft;
    <span class="enscript-type">char</span>* outptr;
    size_t outbytesleft;
    sprintf(ilseq_byte_subst_buffer,
            ilseq_byte_subst, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>)*inbuf);
    inptr = ilseq_byte_subst_buffer;
    inbytesleft = strlen(ilseq_byte_subst_buffer);
    outptr = subst_mb_to_mb_temp_buffer;
    outbytesleft = ilseq_byte_subst_size*4;
    iconv(subst_mb_to_mb_cd,NULL,NULL,NULL,NULL);
    <span class="enscript-keyword">if</span> (iconv(subst_mb_to_mb_cd, (ICONV_CONST <span class="enscript-type">char</span>**)&amp;inptr,&amp;inbytesleft, &amp;outptr,&amp;outbytesleft)
        == (size_t)(-1)
        || iconv(subst_mb_to_mb_cd, NULL,NULL, &amp;outptr,&amp;outbytesleft)
           == (size_t)(-1))
      error(EXIT_FAILURE,0,_(<span class="enscript-string">&quot;cannot convert byte substitution to target encoding: %s&quot;</span>),ilseq_byte_subst_buffer);
    fwrite(subst_mb_to_mb_temp_buffer,1,ilseq_byte_subst_size*4-outbytesleft,
           stdout);
  }
}

<span class="enscript-comment">/* ========================================================================= */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">convert</span> (iconv_t cd, FILE* infile, <span class="enscript-type">const</span> <span class="enscript-type">char</span>* infilename)
{
  <span class="enscript-type">char</span> inbuf[4096+4096];
  size_t inbufrest = 0;
  <span class="enscript-type">char</span> initial_outbuf[4096];
  <span class="enscript-type">char</span> *outbuf = initial_outbuf;
  size_t outbufsize = <span class="enscript-keyword">sizeof</span>(initial_outbuf);
  <span class="enscript-type">int</span> status = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">O_BINARY</span>
  SET_BINARY(fileno(infile));
#<span class="enscript-reference">endif</span>
  line = 1; column = 0;
  iconv(cd,NULL,NULL,NULL,NULL);
  <span class="enscript-keyword">for</span> (;;) {
    size_t inbufsize = fread(inbuf+4096,1,4096,infile);
    <span class="enscript-keyword">if</span> (inbufsize == 0) {
      <span class="enscript-keyword">if</span> (inbufrest == 0)
        <span class="enscript-keyword">break</span>;
      <span class="enscript-keyword">else</span> {
        <span class="enscript-keyword">if</span> (ilseq_byte_subst != NULL)
          subst_mb_to_mb_fallback(inbuf+4096-inbufrest, inbufrest);
        <span class="enscript-keyword">if</span> (!silent) {
          fflush(stdout);
          <span class="enscript-keyword">if</span> (column &gt; 0)
            putc(<span class="enscript-string">'\n'</span>,stderr);
          error(0,0,_(<span class="enscript-string">&quot;%s:%u:%u: incomplete character or shift sequence&quot;</span>),infilename,line,column);
        }
        status = 1;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
      }
    } <span class="enscript-keyword">else</span> {
      <span class="enscript-type">const</span> <span class="enscript-type">char</span>* inptr = inbuf+4096-inbufrest;
      size_t insize = inbufrest+inbufsize;
      inbufrest = 0;
      <span class="enscript-keyword">while</span> (insize &gt; 0) {
        <span class="enscript-type">char</span>* outptr = outbuf;
        size_t outsize = outbufsize;
        size_t res = iconv(cd,(ICONV_CONST <span class="enscript-type">char</span>**)&amp;inptr,&amp;insize,&amp;outptr,&amp;outsize);
        <span class="enscript-keyword">if</span> (outptr != outbuf) {
          <span class="enscript-type">int</span> saved_errno = errno;
          <span class="enscript-keyword">if</span> (fwrite(outbuf,1,outptr-outbuf,stdout) &lt; outptr-outbuf) {
            status = 1;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
          }
          errno = saved_errno;
        }
        <span class="enscript-keyword">if</span> (res == (size_t)(-1)) {
          <span class="enscript-keyword">if</span> (errno == EILSEQ) {
            <span class="enscript-keyword">if</span> (discard_unconvertible == 1) {
              <span class="enscript-type">int</span> one = 1;
              iconvctl(cd,ICONV_SET_DISCARD_ILSEQ,&amp;one);
              discard_unconvertible = 2;
              status = 1;
            } <span class="enscript-keyword">else</span> {
              <span class="enscript-keyword">if</span> (!silent) {
                fflush(stdout);
                <span class="enscript-keyword">if</span> (column &gt; 0)
                  putc(<span class="enscript-string">'\n'</span>,stderr);
                error(0,0,_(<span class="enscript-string">&quot;%s:%u:%u: cannot convert&quot;</span>),infilename,line,column);
              }
              status = 1;
              <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
            }
          } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (errno == EINVAL) {
            <span class="enscript-keyword">if</span> (inbufsize == 0 || insize &gt; 4096) {
              <span class="enscript-keyword">if</span> (!silent) {
                fflush(stdout);
                <span class="enscript-keyword">if</span> (column &gt; 0)
                  putc(<span class="enscript-string">'\n'</span>,stderr);
                error(0,0,_(<span class="enscript-string">&quot;%s:%u:%u: incomplete character or shift sequence&quot;</span>),infilename,line,column);
              }
              status = 1;
              <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
            } <span class="enscript-keyword">else</span> {
              inbufrest = insize;
              <span class="enscript-keyword">if</span> (insize &gt; 0) {
                <span class="enscript-comment">/* Like memcpy(inbuf+4096-insize,inptr,insize), except that
                   we cannot use memcpy here, because source and destination
                   regions may overlap. */</span>
                <span class="enscript-type">char</span>* restptr = inbuf+4096-insize;
                <span class="enscript-keyword">do</span> { *restptr++ = *inptr++; } <span class="enscript-keyword">while</span> (--insize &gt; 0);
              }
              <span class="enscript-keyword">break</span>;
            }
          } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (errno == E2BIG) {
            <span class="enscript-keyword">if</span> (outptr==outbuf) {
              <span class="enscript-comment">/* outbuf is too small. Double its size. */</span>
              <span class="enscript-keyword">if</span> (outbuf != initial_outbuf)
                free(outbuf);
              outbufsize = 2*outbufsize;
              <span class="enscript-keyword">if</span> (outbufsize==0) <span class="enscript-comment">/* integer overflow? */</span>
                xalloc_die();
              outbuf = (<span class="enscript-type">char</span>*)xmalloc(outbufsize);
            }
          } <span class="enscript-keyword">else</span> {
            <span class="enscript-keyword">if</span> (!silent) {
              <span class="enscript-type">int</span> saved_errno = errno;
              fflush(stdout);
              <span class="enscript-keyword">if</span> (column &gt; 0)
                putc(<span class="enscript-string">'\n'</span>,stderr);
              error(0,saved_errno,_(<span class="enscript-string">&quot;%s:%u:%u&quot;</span>),infilename,line,column);
            }
            status = 1;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
          }
        }
      }
    }
  }
  <span class="enscript-keyword">for</span> (;;) {
    <span class="enscript-type">char</span>* outptr = outbuf;
    size_t outsize = outbufsize;
    size_t res = iconv(cd,NULL,NULL,&amp;outptr,&amp;outsize);
    <span class="enscript-keyword">if</span> (outptr != outbuf) {
      <span class="enscript-type">int</span> saved_errno = errno;
      <span class="enscript-keyword">if</span> (fwrite(outbuf,1,outptr-outbuf,stdout) &lt; outptr-outbuf) {
        status = 1;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
      }
      errno = saved_errno;
    }
    <span class="enscript-keyword">if</span> (res == (size_t)(-1)) {
      <span class="enscript-keyword">if</span> (errno == EILSEQ) {
        <span class="enscript-keyword">if</span> (discard_unconvertible == 1) {
          <span class="enscript-type">int</span> one = 1;
          iconvctl(cd,ICONV_SET_DISCARD_ILSEQ,&amp;one);
          discard_unconvertible = 2;
          status = 1;
        } <span class="enscript-keyword">else</span> {
          <span class="enscript-keyword">if</span> (!silent) {
            fflush(stdout);
            <span class="enscript-keyword">if</span> (column &gt; 0)
              putc(<span class="enscript-string">'\n'</span>,stderr);
            error(0,0,_(<span class="enscript-string">&quot;%s:%u:%u: cannot convert&quot;</span>),infilename,line,column);
          }
          status = 1;
          <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
        }
      } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (errno == EINVAL) {
        <span class="enscript-keyword">if</span> (!silent) {
          fflush(stdout);
          <span class="enscript-keyword">if</span> (column &gt; 0)
            putc(<span class="enscript-string">'\n'</span>,stderr);
          error(0,0,_(<span class="enscript-string">&quot;%s:%u:%u: incomplete character or shift sequence&quot;</span>),infilename,line,column);
        }
        status = 1;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
      } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (errno == E2BIG) {
        <span class="enscript-keyword">if</span> (outptr==outbuf) {
          <span class="enscript-comment">/* outbuf is too small. Double its size. */</span>
          <span class="enscript-keyword">if</span> (outbuf != initial_outbuf)
            free(outbuf);
          outbufsize = 2*outbufsize;
          <span class="enscript-keyword">if</span> (outbufsize==0) <span class="enscript-comment">/* integer overflow? */</span>
            xalloc_die();
          outbuf = (<span class="enscript-type">char</span>*)xmalloc(outbufsize);
        }
      } <span class="enscript-keyword">else</span> {
        <span class="enscript-keyword">if</span> (!silent) {
          <span class="enscript-type">int</span> saved_errno = errno;
          fflush(stdout);
          <span class="enscript-keyword">if</span> (column &gt; 0)
            putc(<span class="enscript-string">'\n'</span>,stderr);
          error(0,saved_errno,_(<span class="enscript-string">&quot;%s:%u:%u&quot;</span>),infilename,line,column);
        }
        status = 1;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
      }
    } <span class="enscript-keyword">else</span>
      <span class="enscript-keyword">break</span>;
  }
  <span class="enscript-keyword">if</span> (ferror(infile)) {
    fflush(stdout);
    <span class="enscript-keyword">if</span> (column &gt; 0)
      putc(<span class="enscript-string">'\n'</span>,stderr);
    error(0,0,_(<span class="enscript-string">&quot;%s: I/O error&quot;</span>),infilename);
    status = 1;
    <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
  }
 <span class="enscript-reference">done</span>:
  <span class="enscript-keyword">if</span> (outbuf != initial_outbuf)
    free(outbuf);
  <span class="enscript-keyword">return</span> status;
}

<span class="enscript-comment">/* ========================================================================= */</span>

<span class="enscript-type">int</span> <span class="enscript-function-name">main</span> (<span class="enscript-type">int</span> argc, <span class="enscript-type">char</span>* argv[])
{
  <span class="enscript-type">const</span> <span class="enscript-type">char</span>* fromcode = NULL;
  <span class="enscript-type">const</span> <span class="enscript-type">char</span>* tocode = NULL;
  <span class="enscript-type">int</span> do_list = 0;
  iconv_t cd;
  <span class="enscript-type">struct</span> iconv_fallbacks fallbacks;
  <span class="enscript-type">struct</span> iconv_hooks hooks;
  <span class="enscript-type">int</span> i;
  <span class="enscript-type">int</span> status;

  set_program_name (argv[0]);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HAVE_SETLOCALE</span>
  <span class="enscript-comment">/* Needed for the locale dependent encodings, &quot;char&quot; and &quot;wchar_t&quot;,
     and for gettext. */</span>
  setlocale(LC_CTYPE,<span class="enscript-string">&quot;&quot;</span>);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ENABLE_NLS</span>
  <span class="enscript-comment">/* Needed for gettext. */</span>
  setlocale(LC_MESSAGES,<span class="enscript-string">&quot;&quot;</span>);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ENABLE_NLS</span>
  bindtextdomain(<span class="enscript-string">&quot;libiconv&quot;</span>,relocate(LOCALEDIR));
  textdomain(<span class="enscript-string">&quot;libiconv&quot;</span>);
#<span class="enscript-reference">endif</span>
  <span class="enscript-keyword">for</span> (i = 1; i &lt; argc;) {
    size_t len = strlen(argv[i]);
    <span class="enscript-keyword">if</span> (!strcmp(argv[i],<span class="enscript-string">&quot;--&quot;</span>)) {
      i++;
      <span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">if</span> (!strcmp(argv[i],<span class="enscript-string">&quot;-f&quot;</span>)
        <span class="enscript-comment">/* --f ... --from-code */</span>
        || (len &gt;= 3 &amp;&amp; len &lt;= 11 &amp;&amp; !strncmp(argv[i],<span class="enscript-string">&quot;--from-code&quot;</span>,len))
        <span class="enscript-comment">/* --from-code=... */</span>
        || (len &gt;= 12 &amp;&amp; !strncmp(argv[i],<span class="enscript-string">&quot;--from-code=&quot;</span>,12))) {
      <span class="enscript-keyword">if</span> (len &lt; 12)
        <span class="enscript-keyword">if</span> (i == argc-1) usage(1);
      <span class="enscript-keyword">if</span> (fromcode != NULL) usage(1);
      <span class="enscript-keyword">if</span> (len &lt; 12) {
        fromcode = argv[i+1];
        i += 2;
      } <span class="enscript-keyword">else</span> {
        fromcode = argv[i]+12;
        i++;
      }
      <span class="enscript-keyword">continue</span>;
    }
    <span class="enscript-keyword">if</span> (!strcmp(argv[i],<span class="enscript-string">&quot;-t&quot;</span>)
        <span class="enscript-comment">/* --t ... --to-code */</span>
        || (len &gt;= 3 &amp;&amp; len &lt;= 9 &amp;&amp; !strncmp(argv[i],<span class="enscript-string">&quot;--to-code&quot;</span>,len))
        <span class="enscript-comment">/* --from-code=... */</span>
        || (len &gt;= 10 &amp;&amp; !strncmp(argv[i],<span class="enscript-string">&quot;--to-code=&quot;</span>,10))) {
      <span class="enscript-keyword">if</span> (len &lt; 10)
        <span class="enscript-keyword">if</span> (i == argc-1) usage(1);
      <span class="enscript-keyword">if</span> (tocode != NULL) usage(1);
      <span class="enscript-keyword">if</span> (len &lt; 10) {
        tocode = argv[i+1];
        i += 2;
      } <span class="enscript-keyword">else</span> {
        tocode = argv[i]+10;
        i++;
      }
      <span class="enscript-keyword">continue</span>;
    }
    <span class="enscript-keyword">if</span> (!strcmp(argv[i],<span class="enscript-string">&quot;-l&quot;</span>)
        <span class="enscript-comment">/* --l ... --list */</span>
        || (len &gt;= 3 &amp;&amp; len &lt;= 6 &amp;&amp; !strncmp(argv[i],<span class="enscript-string">&quot;--list&quot;</span>,len))) {
      do_list = 1;
      i++;
      <span class="enscript-keyword">continue</span>;
    }
    <span class="enscript-keyword">if</span> (<span class="enscript-comment">/* --by ... --byte-subst */</span>
        (len &gt;= 4 &amp;&amp; len &lt;= 12 &amp;&amp; !strncmp(argv[i],<span class="enscript-string">&quot;--byte-subst&quot;</span>,len))
        <span class="enscript-comment">/* --byte-subst=... */</span>
        || (len &gt;= 13 &amp;&amp; !strncmp(argv[i],<span class="enscript-string">&quot;--byte-subst=&quot;</span>,13))) {
      <span class="enscript-keyword">if</span> (len &lt; 13) {
        <span class="enscript-keyword">if</span> (i == argc-1) usage(1);
        ilseq_byte_subst = argv[i+1];
        i += 2;
      } <span class="enscript-keyword">else</span> {
        ilseq_byte_subst = argv[i]+13;
        i++;
      }
      ilseq_byte_subst_size =
        check_subst_formatstring(ilseq_byte_subst, <span class="enscript-string">&quot;--byte-subst&quot;</span>);
      <span class="enscript-keyword">continue</span>;
    }
    <span class="enscript-keyword">if</span> (<span class="enscript-comment">/* --w ... --widechar-subst */</span>
        (len &gt;= 3 &amp;&amp; len &lt;= 16 &amp;&amp; !strncmp(argv[i],<span class="enscript-string">&quot;--widechar-subst&quot;</span>,len))
        <span class="enscript-comment">/* --widechar-subst=... */</span>
        || (len &gt;= 17 &amp;&amp; !strncmp(argv[i],<span class="enscript-string">&quot;--widechar-subst=&quot;</span>,17))) {
      <span class="enscript-keyword">if</span> (len &lt; 17) {
        <span class="enscript-keyword">if</span> (i == argc-1) usage(1);
        ilseq_wchar_subst = argv[i+1];
        i += 2;
      } <span class="enscript-keyword">else</span> {
        ilseq_wchar_subst = argv[i]+17;
        i++;
      }
      ilseq_wchar_subst_size =
        check_subst_formatstring(ilseq_wchar_subst, <span class="enscript-string">&quot;--widechar-subst&quot;</span>);
      <span class="enscript-keyword">continue</span>;
    }
    <span class="enscript-keyword">if</span> (<span class="enscript-comment">/* --u ... --unicode-subst */</span>
        (len &gt;= 3 &amp;&amp; len &lt;= 15 &amp;&amp; !strncmp(argv[i],<span class="enscript-string">&quot;--unicode-subst&quot;</span>,len))
        <span class="enscript-comment">/* --unicode-subst=... */</span>
        || (len &gt;= 16 &amp;&amp; !strncmp(argv[i],<span class="enscript-string">&quot;--unicode-subst=&quot;</span>,16))) {
      <span class="enscript-keyword">if</span> (len &lt; 16) {
        <span class="enscript-keyword">if</span> (i == argc-1) usage(1);
        ilseq_unicode_subst = argv[i+1];
        i += 2;
      } <span class="enscript-keyword">else</span> {
        ilseq_unicode_subst = argv[i]+16;
        i++;
      }
      ilseq_unicode_subst_size =
        check_subst_formatstring(ilseq_unicode_subst, <span class="enscript-string">&quot;--unicode-subst&quot;</span>);
      <span class="enscript-keyword">continue</span>;
    }
    <span class="enscript-keyword">if</span> <span class="enscript-comment">/* --s ... --silent */</span>
       (len &gt;= 3 &amp;&amp; len &lt;= 8 &amp;&amp; !strncmp(argv[i],<span class="enscript-string">&quot;--silent&quot;</span>,len)) {
      silent = 1;
      <span class="enscript-keyword">continue</span>;
    }
    <span class="enscript-keyword">if</span> <span class="enscript-comment">/* --h ... --help */</span>
       (len &gt;= 3 &amp;&amp; len &lt;= 6 &amp;&amp; !strncmp(argv[i],<span class="enscript-string">&quot;--help&quot;</span>,len)) {
      usage(0);
    }
    <span class="enscript-keyword">if</span> <span class="enscript-comment">/* --v ... --version */</span>
       (len &gt;= 3 &amp;&amp; len &lt;= 9 &amp;&amp; !strncmp(argv[i],<span class="enscript-string">&quot;--version&quot;</span>,len)) {
      print_version();
    }
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">O_BINARY</span>
    <span class="enscript-comment">/* Backward compatibility with iconv &lt;= 1.9.1. */</span>
    <span class="enscript-keyword">if</span> <span class="enscript-comment">/* --bi ... --binary */</span>
       (len &gt;= 4 &amp;&amp; len &lt;= 8 &amp;&amp; !strncmp(argv[i],<span class="enscript-string">&quot;--binary&quot;</span>,len)) {
      i++;
      <span class="enscript-keyword">continue</span>;
    }
#<span class="enscript-reference">endif</span>
    <span class="enscript-keyword">if</span> (argv[i][0] == <span class="enscript-string">'-'</span>) {
      <span class="enscript-type">const</span> <span class="enscript-type">char</span> *option = argv[i] + 1;
      <span class="enscript-keyword">if</span> (*option == <span class="enscript-string">'\0'</span>)
        usage(1);
      <span class="enscript-keyword">if</span> (!strcmp(option,<span class="enscript-string">&quot;-&quot;</span>)) { <span class="enscript-comment">/* handle -- option delimiter */</span>
	i++;
	<span class="enscript-keyword">break</span>;
      }
      <span class="enscript-keyword">for</span> (; *option; option++)
        <span class="enscript-keyword">switch</span> (*option) {
          <span class="enscript-keyword">case</span> <span class="enscript-string">'c'</span>: discard_unconvertible = 1; <span class="enscript-keyword">break</span>;
          <span class="enscript-keyword">case</span> <span class="enscript-string">'s'</span>: silent = 1; <span class="enscript-keyword">break</span>;
          <span class="enscript-reference">default</span>: usage(1);
        }
      i++;
      <span class="enscript-keyword">continue</span>;
    }
    <span class="enscript-keyword">break</span>;
  }
  <span class="enscript-keyword">if</span> (do_list) {
    <span class="enscript-keyword">if</span> (i != 2 || i != argc)
      usage(1);
    iconvlist(print_one,NULL);
    status = 0;
  } <span class="enscript-keyword">else</span> {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">O_BINARY</span>
    SET_BINARY(fileno(stdout));
#<span class="enscript-reference">endif</span>
    <span class="enscript-keyword">if</span> (fromcode == NULL)
      fromcode = <span class="enscript-string">&quot;char&quot;</span>;
    <span class="enscript-keyword">if</span> (tocode == NULL)
      tocode = <span class="enscript-string">&quot;char&quot;</span>;
    cd = iconv_open(tocode,fromcode);
    <span class="enscript-keyword">if</span> (cd == (iconv_t)(-1)) {
      <span class="enscript-keyword">if</span> (iconv_open(<span class="enscript-string">&quot;UCS-4&quot;</span>,fromcode) == (iconv_t)(-1))
        error(0,0,_(<span class="enscript-string">&quot;conversion from %s unsupported&quot;</span>),fromcode);
      <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (iconv_open(tocode,<span class="enscript-string">&quot;UCS-4&quot;</span>) == (iconv_t)(-1))
        error(0,0,_(<span class="enscript-string">&quot;conversion to %s unsupported&quot;</span>),tocode);
      <span class="enscript-keyword">else</span>
        error(0,0,_(<span class="enscript-string">&quot;conversion from %s to %s unsupported&quot;</span>),fromcode,tocode);
      error(EXIT_FAILURE,0,_(<span class="enscript-string">&quot;try '%s -l' to get the list of supported encodings&quot;</span>),program_name);
    }
    <span class="enscript-comment">/* Look at fromcode and tocode, to determine whether character widths
       should be determined according to legacy CJK conventions. */</span>
    cjkcode = iconv_canonicalize(tocode);
    <span class="enscript-keyword">if</span> (!is_cjk_encoding(cjkcode))
      cjkcode = iconv_canonicalize(fromcode);
    <span class="enscript-comment">/* Set up fallback routines for handling impossible conversions. */</span>
    <span class="enscript-keyword">if</span> (ilseq_byte_subst != NULL)
      ilseq_byte_subst_buffer = (<span class="enscript-type">char</span>*)xmalloc((ilseq_byte_subst_size+1)*<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">char</span>));
    <span class="enscript-keyword">if</span> (!discard_unconvertible) {
      #<span class="enscript-keyword">if</span> HAVE_WCHAR_T
      <span class="enscript-keyword">if</span> (ilseq_wchar_subst != NULL)
        ilseq_wchar_subst_buffer = (<span class="enscript-type">char</span>*)xmalloc((ilseq_wchar_subst_size+1)*<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">char</span>));
      #endif
      <span class="enscript-keyword">if</span> (ilseq_unicode_subst != NULL)
        ilseq_unicode_subst_buffer = (<span class="enscript-type">char</span>*)xmalloc((ilseq_unicode_subst_size+1)*<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">char</span>));
      <span class="enscript-keyword">if</span> (ilseq_byte_subst != NULL) {
        subst_mb_to_uc_cd = iconv_open(<span class="enscript-string">&quot;UCS-4-INTERNAL&quot;</span>,<span class="enscript-string">&quot;char&quot;</span>);
        subst_mb_to_uc_temp_buffer = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>*)xmalloc(ilseq_byte_subst_size*<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>));
        #<span class="enscript-keyword">if</span> HAVE_WCHAR_T
        subst_mb_to_wc_cd = iconv_open(<span class="enscript-string">&quot;wchar_t&quot;</span>,<span class="enscript-string">&quot;char&quot;</span>);
        subst_mb_to_wc_temp_buffer = (wchar_t*)xmalloc(ilseq_byte_subst_size*<span class="enscript-keyword">sizeof</span>(wchar_t));
        #endif
        subst_mb_to_mb_cd = iconv_open(tocode,<span class="enscript-string">&quot;char&quot;</span>);
        subst_mb_to_mb_temp_buffer = (<span class="enscript-type">char</span>*)xmalloc(ilseq_byte_subst_size*4);
      }
      #<span class="enscript-keyword">if</span> HAVE_WCHAR_T
      <span class="enscript-keyword">if</span> (ilseq_wchar_subst != NULL) {
        subst_wc_to_mb_cd = iconv_open(tocode,<span class="enscript-string">&quot;char&quot;</span>);
        subst_wc_to_mb_temp_buffer = (<span class="enscript-type">char</span>*)xmalloc(ilseq_wchar_subst_size*4);
      }
      #endif
      <span class="enscript-keyword">if</span> (ilseq_unicode_subst != NULL) {
        subst_uc_to_mb_cd = iconv_open(tocode,<span class="enscript-string">&quot;char&quot;</span>);
        subst_uc_to_mb_temp_buffer = (<span class="enscript-type">char</span>*)xmalloc(ilseq_unicode_subst_size*4);
      }
      fallbacks.mb_to_uc_fallback =
        (ilseq_byte_subst != NULL ? subst_mb_to_uc_fallback : NULL);
      fallbacks.uc_to_mb_fallback =
        (ilseq_unicode_subst != NULL ? subst_uc_to_mb_fallback : NULL);
      fallbacks.mb_to_wc_fallback =
        (ilseq_byte_subst != NULL ? subst_mb_to_wc_fallback : NULL);
      fallbacks.wc_to_mb_fallback =
        (ilseq_wchar_subst != NULL ? subst_wc_to_mb_fallback : NULL);
      fallbacks.data = NULL;
      iconvctl(cd, ICONV_SET_FALLBACKS, &amp;fallbacks);
    }
    <span class="enscript-comment">/* Set up hooks for updating the line and column position. */</span>
    hooks.uc_hook = update_line_column;
    hooks.wc_hook = NULL;
    hooks.data = NULL;
    iconvctl(cd, ICONV_SET_HOOKS, &amp;hooks);
    <span class="enscript-keyword">if</span> (i == argc)
      status = convert(cd,stdin,_(<span class="enscript-string">&quot;(stdin)&quot;</span>));
    <span class="enscript-keyword">else</span> {
      status = 0;
      <span class="enscript-keyword">for</span> (; i &lt; argc; i++) {
        <span class="enscript-type">const</span> <span class="enscript-type">char</span>* infilename = argv[i];
        FILE* infile = fopen(infilename,<span class="enscript-string">&quot;r&quot;</span>);
        <span class="enscript-keyword">if</span> (infile == NULL) {
          <span class="enscript-type">int</span> saved_errno = errno;
          error(0,saved_errno,_(<span class="enscript-string">&quot;%s&quot;</span>),infilename);
          status = 1;
        } <span class="enscript-keyword">else</span> {
          status |= convert(cd,infile,infilename);
          fclose(infile);
        }
      }
    }
    iconv_close(cd);
  }
  <span class="enscript-keyword">if</span> (ferror(stdout) || fclose(stdout)) {
    error(0,0,_(<span class="enscript-string">&quot;I/O error&quot;</span>));
    status = 1;
  }
  exit(status);
}
</pre>
<hr />
</body></html>