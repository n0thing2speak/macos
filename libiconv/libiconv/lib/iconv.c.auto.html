<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>iconv.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">iconv.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (C) 1999-2006 Free Software Foundation, Inc.
 * This file is part of the GNU LIBICONV Library.
 *
 * The GNU LIBICONV Library is free software; you can redistribute it
 * and/or modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * The GNU LIBICONV Library is distributed in the hope that it will be
 * useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with the GNU LIBICONV Library; see the file COPYING.LIB.
 * If not, write to the Free Software Foundation, Inc., 51 Franklin Street,
 * Fifth Floor, Boston, MA 02110-1301, USA.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;iconv.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;config.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;localcharset.h&quot;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ENABLE_EXTRA</span>
<span class="enscript-comment">/*
 * Consider all system dependent encodings, for any system,
 * and the extra encodings.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">USE_AIX</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">USE_OSF1</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">USE_DOS</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">USE_EXTRA</span>
#<span class="enscript-reference">else</span>
<span class="enscript-comment">/*
 * Consider those system dependent encodings that are needed for the
 * current system.
 */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_AIX</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">USE_AIX</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__osf__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">VMS</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">USE_OSF1</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__DJGPP__</span>) || (<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">_WIN32</span>) &amp;&amp; (<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">_MSC_VER</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__MINGW32__</span>)))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">USE_DOS</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Data type for general conversion loop.
 */</span>
<span class="enscript-type">struct</span> loop_funcs {
  size_t (*loop_convert) (iconv_t icd,
                          <span class="enscript-type">const</span> <span class="enscript-type">char</span>* * inbuf, size_t *inbytesleft,
                          <span class="enscript-type">char</span>* * outbuf, size_t *outbytesleft);
  size_t (*loop_reset) (iconv_t icd,
                        <span class="enscript-type">char</span>* * outbuf, size_t *outbytesleft);
};

<span class="enscript-comment">/*
 * Converters.
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;converters.h&quot;</span>

<span class="enscript-comment">/*
 * Transliteration tables.
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;cjk_variants.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;translit.h&quot;</span>

<span class="enscript-comment">/*
 * Table of all supported encodings.
 */</span>
<span class="enscript-type">struct</span> encoding {
  <span class="enscript-type">struct</span> mbtowc_funcs ifuncs; <span class="enscript-comment">/* conversion multibyte -&gt; unicode */</span>
  <span class="enscript-type">struct</span> wctomb_funcs ofuncs; <span class="enscript-comment">/* conversion unicode -&gt; multibyte */</span>
  <span class="enscript-type">int</span> oflags;                 <span class="enscript-comment">/* flags for unicode -&gt; multibyte conversion */</span>
};
<span class="enscript-type">enum</span> {
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DEFENCODING</span>(xxx_names,xxx,xxx_ifuncs1,xxx_ifuncs2,xxx_ofuncs1,xxx_ofuncs2) \
  ei_##xxx ,
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;encodings.def&quot;</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">USE_AIX</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;encodings_aix.def&quot;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">USE_OSF1</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;encodings_osf1.def&quot;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">USE_DOS</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;encodings_dos.def&quot;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">USE_EXTRA</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;encodings_extra.def&quot;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;encodings_local.def&quot;</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">DEFENCODING</span>
ei_for_broken_compilers_that_dont_like_trailing_commas
};
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;flags.h&quot;</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> encoding <span class="enscript-type">const</span> all_encodings[] = {
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DEFENCODING</span>(xxx_names,xxx,xxx_ifuncs1,xxx_ifuncs2,xxx_ofuncs1,xxx_ofuncs2) \
  { xxx_ifuncs1,xxx_ifuncs2, xxx_ofuncs1,xxx_ofuncs2, ei_##xxx##_oflags },
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;encodings.def&quot;</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">USE_AIX</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;encodings_aix.def&quot;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">USE_OSF1</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;encodings_osf1.def&quot;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">USE_DOS</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;encodings_dos.def&quot;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">USE_EXTRA</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;encodings_extra.def&quot;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">DEFENCODING</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DEFENCODING</span>(xxx_names,xxx,xxx_ifuncs1,xxx_ifuncs2,xxx_ofuncs1,xxx_ofuncs2) \
  { xxx_ifuncs1,xxx_ifuncs2, xxx_ofuncs1,xxx_ofuncs2, 0 },
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;encodings_local.def&quot;</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">DEFENCODING</span>
};

<span class="enscript-comment">/*
 * Conversion loops.
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;loops.h&quot;</span>

<span class="enscript-comment">/*
 * Alias lookup function.
 * Defines
 *   struct alias { int name; unsigned int encoding_index; };
 *   const struct alias * aliases_lookup (const char *str, unsigned int len);
 *   #define MAX_WORD_LENGTH ...
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;aliases.h&quot;</span>

<span class="enscript-comment">/*
 * System dependent alias lookup function.
 * Defines
 *   const struct alias * aliases2_lookup (const char *str);
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">USE_AIX</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">USE_OSF1</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">USE_DOS</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">USE_EXTRA</span>) <span class="enscript-comment">/* || ... */</span>
<span class="enscript-type">struct</span> stringpool2_t {
#<span class="enscript-reference">define</span> <span class="enscript-function-name">S</span>(tag,name,encoding_index) char stringpool_##tag[sizeof(name)];
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;aliases2.h&quot;</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">S</span>
};
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> stringpool2_t stringpool2_contents = {
#<span class="enscript-reference">define</span> <span class="enscript-function-name">S</span>(tag,name,encoding_index) name,
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;aliases2.h&quot;</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">S</span>
};
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">stringpool2</span> ((const char *) &amp;stringpool2_contents)
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> alias sysdep_aliases[] = {
#<span class="enscript-reference">define</span> <span class="enscript-function-name">S</span>(tag,name,encoding_index) { (int)(long)&amp;((struct stringpool2_t *)0)-&gt;stringpool_##tag, encoding_index },
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;aliases2.h&quot;</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">S</span>
};
<span class="enscript-type">const</span> <span class="enscript-type">struct</span> alias *
<span class="enscript-function-name">aliases2_lookup</span> (<span class="enscript-type">register</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *str)
{
  <span class="enscript-type">const</span> <span class="enscript-type">struct</span> alias * ptr;
  <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> count;
  <span class="enscript-keyword">for</span> (ptr = sysdep_aliases, count = <span class="enscript-keyword">sizeof</span>(sysdep_aliases)/<span class="enscript-keyword">sizeof</span>(sysdep_aliases[0]); count &gt; 0; ptr++, count--)
    <span class="enscript-keyword">if</span> (!strcmp(str, stringpool2 + ptr-&gt;name))
      <span class="enscript-keyword">return</span> ptr;
  <span class="enscript-keyword">return</span> NULL;
}
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">aliases2_lookup</span>(str)  NULL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">stringpool2</span>  NULL
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/* Like !strcasecmp, except that the both strings can be assumed to be ASCII
   and the first string can be assumed to be in uppercase. */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">strequal</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span>* str1, <span class="enscript-type">const</span> <span class="enscript-type">char</span>* str2)
{
  <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> c1;
  <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> c2;
  <span class="enscript-keyword">for</span> (;;) {
    c1 = * (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *) str1++;
    c2 = * (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *) str2++;
    <span class="enscript-keyword">if</span> (c1 == 0)
      <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">if</span> (c2 &gt;= <span class="enscript-string">'a'</span> &amp;&amp; c2 &lt;= <span class="enscript-string">'z'</span>)
      c2 -= <span class="enscript-string">'a'</span>-<span class="enscript-string">'A'</span>;
    <span class="enscript-keyword">if</span> (c1 != c2)
      <span class="enscript-keyword">break</span>;
  }
  <span class="enscript-keyword">return</span> (c1 == c2);
}
#<span class="enscript-reference">endif</span>

iconv_t <span class="enscript-function-name">iconv_open</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span>* tocode, <span class="enscript-type">const</span> <span class="enscript-type">char</span>* fromcode)
{
  <span class="enscript-type">struct</span> conv_struct * cd;
  <span class="enscript-type">char</span> buf[MAX_WORD_LENGTH+10+1];
  <span class="enscript-type">const</span> <span class="enscript-type">char</span>* cp;
  <span class="enscript-type">char</span>* bp;
  <span class="enscript-type">const</span> <span class="enscript-type">struct</span> alias * ap;
  <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> count;
  <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> from_index;
  <span class="enscript-type">int</span> from_wchar;
  <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> to_index;
  <span class="enscript-type">int</span> to_wchar;
  <span class="enscript-type">int</span> transliterate = 0;
  <span class="enscript-type">int</span> discard_ilseq = 0;

  <span class="enscript-comment">/* Before calling aliases_lookup, convert the input string to upper case,
   * and check whether it's entirely ASCII (we call gperf with option &quot;-7&quot;
   * to achieve a smaller table) and non-empty. If it's not entirely ASCII,
   * or if it's too long, it is not a valid encoding name.
   */</span>
  <span class="enscript-keyword">for</span> (to_wchar = 0;;) {
    <span class="enscript-comment">/* Search tocode in the table. */</span>
    <span class="enscript-keyword">for</span> (cp = tocode, bp = buf, count = MAX_WORD_LENGTH+10+1; ; cp++, bp++) {
      <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> c = * (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *) cp;
      <span class="enscript-keyword">if</span> (c &gt;= 0x80)
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid</span>;
      <span class="enscript-keyword">if</span> (c &gt;= <span class="enscript-string">'a'</span> &amp;&amp; c &lt;= <span class="enscript-string">'z'</span>)
        c -= <span class="enscript-string">'a'</span>-<span class="enscript-string">'A'</span>;
      *bp = c;
      <span class="enscript-keyword">if</span> (c == <span class="enscript-string">'\0'</span>)
        <span class="enscript-keyword">break</span>;
      <span class="enscript-keyword">if</span> (--count == 0)
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid</span>;
    }
    <span class="enscript-keyword">for</span> (;;) {
      <span class="enscript-keyword">if</span> (bp-buf &gt;= 10 &amp;&amp; memcmp(bp-10,<span class="enscript-string">&quot;//TRANSLIT&quot;</span>,10)==0) {
        bp -= 10;
        *bp = <span class="enscript-string">'\0'</span>;
        transliterate = 1;
        <span class="enscript-keyword">continue</span>;
      }
      <span class="enscript-keyword">if</span> (bp-buf &gt;= 8 &amp;&amp; memcmp(bp-8,<span class="enscript-string">&quot;//IGNORE&quot;</span>,8)==0) {
        bp -= 8;
        *bp = <span class="enscript-string">'\0'</span>;
        discard_ilseq = 1;
        <span class="enscript-keyword">continue</span>;
      }
      <span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">if</span> (buf[0] == <span class="enscript-string">'\0'</span>) {
      tocode = locale_charset();
      <span class="enscript-comment">/* Avoid an endless loop that could occur when using an older version
         of localcharset.c. */</span>
      <span class="enscript-keyword">if</span> (tocode[0] == <span class="enscript-string">'\0'</span>)
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid</span>;
      <span class="enscript-keyword">continue</span>;
    }
    ap = aliases_lookup(buf,(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)(bp-buf));
    <span class="enscript-keyword">if</span> (ap == NULL) {
      ap = aliases2_lookup(buf);
      <span class="enscript-keyword">if</span> (ap == NULL)
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid</span>;
    }
    <span class="enscript-keyword">if</span> (ap-&gt;encoding_index == ei_local_char) {
      tocode = locale_charset();
      <span class="enscript-comment">/* Avoid an endless loop that could occur when using an older version
         of localcharset.c. */</span>
      <span class="enscript-keyword">if</span> (tocode[0] == <span class="enscript-string">'\0'</span>)
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid</span>;
      <span class="enscript-keyword">continue</span>;
    }
    <span class="enscript-keyword">if</span> (ap-&gt;encoding_index == ei_local_wchar_t) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__STDC_ISO_10646__</span>
      <span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(wchar_t) == 4) {
        to_index = ei_ucs4internal;
        <span class="enscript-keyword">break</span>;
      }
      <span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(wchar_t) == 2) {
        to_index = ei_ucs2internal;
        <span class="enscript-keyword">break</span>;
      }
      <span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(wchar_t) == 1) {
        to_index = ei_iso8859_1;
        <span class="enscript-keyword">break</span>;
      }
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HAVE_MBRTOWC</span>
      to_wchar = 1;
      tocode = locale_charset();
      <span class="enscript-keyword">continue</span>;
#<span class="enscript-reference">endif</span>
      <span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid</span>;
    }
    to_index = ap-&gt;encoding_index;
    <span class="enscript-keyword">break</span>;
  }
  <span class="enscript-keyword">for</span> (from_wchar = 0;;) {
    <span class="enscript-comment">/* Search fromcode in the table. */</span>
    <span class="enscript-keyword">for</span> (cp = fromcode, bp = buf, count = MAX_WORD_LENGTH+10+1; ; cp++, bp++) {
      <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> c = * (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *) cp;
      <span class="enscript-keyword">if</span> (c &gt;= 0x80)
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid</span>;
      <span class="enscript-keyword">if</span> (c &gt;= <span class="enscript-string">'a'</span> &amp;&amp; c &lt;= <span class="enscript-string">'z'</span>)
        c -= <span class="enscript-string">'a'</span>-<span class="enscript-string">'A'</span>;
      *bp = c;
      <span class="enscript-keyword">if</span> (c == <span class="enscript-string">'\0'</span>)
        <span class="enscript-keyword">break</span>;
      <span class="enscript-keyword">if</span> (--count == 0)
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid</span>;
    }
    <span class="enscript-keyword">for</span> (;;) {
      <span class="enscript-keyword">if</span> (bp-buf &gt;= 10 &amp;&amp; memcmp(bp-10,<span class="enscript-string">&quot;//TRANSLIT&quot;</span>,10)==0) {
        bp -= 10;
        *bp = <span class="enscript-string">'\0'</span>;
        <span class="enscript-keyword">continue</span>;
      }
      <span class="enscript-keyword">if</span> (bp-buf &gt;= 8 &amp;&amp; memcmp(bp-8,<span class="enscript-string">&quot;//IGNORE&quot;</span>,8)==0) {
        bp -= 8;
        *bp = <span class="enscript-string">'\0'</span>;
        <span class="enscript-keyword">continue</span>;
      }
      <span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">if</span> (buf[0] == <span class="enscript-string">'\0'</span>) {
      fromcode = locale_charset();
      <span class="enscript-comment">/* Avoid an endless loop that could occur when using an older version
         of localcharset.c. */</span>
      <span class="enscript-keyword">if</span> (fromcode[0] == <span class="enscript-string">'\0'</span>)
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid</span>;
      <span class="enscript-keyword">continue</span>;
    }
    ap = aliases_lookup(buf,(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)(bp-buf));
    <span class="enscript-keyword">if</span> (ap == NULL) {
      ap = aliases2_lookup(buf);
      <span class="enscript-keyword">if</span> (ap == NULL)
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid</span>;
    }
    <span class="enscript-keyword">if</span> (ap-&gt;encoding_index == ei_local_char) {
      fromcode = locale_charset();
      <span class="enscript-comment">/* Avoid an endless loop that could occur when using an older version
         of localcharset.c. */</span>
      <span class="enscript-keyword">if</span> (fromcode[0] == <span class="enscript-string">'\0'</span>)
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid</span>;
      <span class="enscript-keyword">continue</span>;
    }
    <span class="enscript-keyword">if</span> (ap-&gt;encoding_index == ei_local_wchar_t) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__STDC_ISO_10646__</span>
      <span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(wchar_t) == 4) {
        from_index = ei_ucs4internal;
        <span class="enscript-keyword">break</span>;
      }
      <span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(wchar_t) == 2) {
        from_index = ei_ucs2internal;
        <span class="enscript-keyword">break</span>;
      }
      <span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(wchar_t) == 1) {
        from_index = ei_iso8859_1;
        <span class="enscript-keyword">break</span>;
      }
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HAVE_WCRTOMB</span>
      from_wchar = 1;
      fromcode = locale_charset();
      <span class="enscript-keyword">continue</span>;
#<span class="enscript-reference">endif</span>
      <span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid</span>;
    }
    from_index = ap-&gt;encoding_index;
    <span class="enscript-keyword">break</span>;
  }
  cd = (<span class="enscript-type">struct</span> conv_struct *) malloc(from_wchar != to_wchar
                                     ? <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> wchar_conv_struct)
                                     : <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> conv_struct));
  <span class="enscript-keyword">if</span> (cd == NULL) {
    errno = ENOMEM;
    <span class="enscript-keyword">return</span> (iconv_t)(-1);
  }
  cd-&gt;iindex = from_index;
  cd-&gt;ifuncs = all_encodings[from_index].ifuncs;
  cd-&gt;oindex = to_index;
  cd-&gt;ofuncs = all_encodings[to_index].ofuncs;
  cd-&gt;oflags = all_encodings[to_index].oflags;
  <span class="enscript-comment">/* Initialize the loop functions. */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HAVE_MBRTOWC</span>
  <span class="enscript-keyword">if</span> (to_wchar) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HAVE_WCRTOMB</span>
    <span class="enscript-keyword">if</span> (from_wchar) {
      cd-&gt;lfuncs.loop_convert = wchar_id_loop_convert;
      cd-&gt;lfuncs.loop_reset = wchar_id_loop_reset;
    } <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
    {
      cd-&gt;lfuncs.loop_convert = wchar_to_loop_convert;
      cd-&gt;lfuncs.loop_reset = wchar_to_loop_reset;
    }
  } <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
  {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HAVE_WCRTOMB</span>
    <span class="enscript-keyword">if</span> (from_wchar) {
      cd-&gt;lfuncs.loop_convert = wchar_from_loop_convert;
      cd-&gt;lfuncs.loop_reset = wchar_from_loop_reset;
    } <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
    {
      cd-&gt;lfuncs.loop_convert = unicode_loop_convert;
      cd-&gt;lfuncs.loop_reset = unicode_loop_reset;
    }
  }
  <span class="enscript-comment">/* Initialize the states. */</span>
  memset(&amp;cd-&gt;istate,<span class="enscript-string">'\0'</span>,<span class="enscript-keyword">sizeof</span>(state_t));
  memset(&amp;cd-&gt;ostate,<span class="enscript-string">'\0'</span>,<span class="enscript-keyword">sizeof</span>(state_t));
  <span class="enscript-comment">/* Initialize the operation flags. */</span>
  cd-&gt;transliterate = transliterate;
  cd-&gt;discard_ilseq = discard_ilseq;
  #ifndef LIBICONV_PLUG
  cd-&gt;fallbacks.mb_to_uc_fallback = NULL;
  cd-&gt;fallbacks.uc_to_mb_fallback = NULL;
  cd-&gt;fallbacks.mb_to_wc_fallback = NULL;
  cd-&gt;fallbacks.wc_to_mb_fallback = NULL;
  cd-&gt;fallbacks.data = NULL;
  cd-&gt;hooks.uc_hook = NULL;
  cd-&gt;hooks.wc_hook = NULL;
  cd-&gt;hooks.data = NULL;
  #endif
  <span class="enscript-comment">/* Initialize additional fields. */</span>
  <span class="enscript-keyword">if</span> (from_wchar != to_wchar) {
    <span class="enscript-type">struct</span> wchar_conv_struct * wcd = (<span class="enscript-type">struct</span> wchar_conv_struct *) cd;
    memset(&amp;wcd-&gt;state,<span class="enscript-string">'\0'</span>,<span class="enscript-keyword">sizeof</span>(mbstate_t));
  }
  <span class="enscript-comment">/* Done. */</span>
  <span class="enscript-keyword">return</span> (iconv_t)cd;
<span class="enscript-reference">invalid</span>:
  errno = EINVAL;
  <span class="enscript-keyword">return</span> (iconv_t)(-1);
}

size_t <span class="enscript-function-name">iconv</span> (iconv_t icd,
              <span class="enscript-type">char</span>* * __restrict inbuf, size_t * __restrict inbytesleft,
              <span class="enscript-type">char</span>* * __restrict outbuf, size_t * __restrict outbytesleft)
{
  conv_t cd = (conv_t) icd;
  <span class="enscript-keyword">if</span> (inbuf == NULL || *inbuf == NULL)
    <span class="enscript-keyword">return</span> cd-&gt;lfuncs.loop_reset(icd,outbuf,outbytesleft);
  <span class="enscript-keyword">else</span>
    <span class="enscript-keyword">return</span> cd-&gt;lfuncs.loop_convert(icd,
                                   (<span class="enscript-type">const</span> <span class="enscript-type">char</span>* *)inbuf,inbytesleft,
                                   outbuf,outbytesleft);
}

<span class="enscript-type">int</span> <span class="enscript-function-name">iconv_close</span> (iconv_t icd)
{
  conv_t cd = (conv_t) icd;
  free(cd);
  <span class="enscript-keyword">return</span> 0;
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">LIBICONV_PLUG</span>

<span class="enscript-type">int</span> <span class="enscript-function-name">iconvctl</span> (iconv_t icd, <span class="enscript-type">int</span> request, <span class="enscript-type">void</span>* argument)
{
  conv_t cd = (conv_t) icd;
  <span class="enscript-keyword">switch</span> (request) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">ICONV_TRIVIALP</span>:
      *(<span class="enscript-type">int</span> *)argument =
        ((cd-&gt;lfuncs.loop_convert == unicode_loop_convert
          &amp;&amp; cd-&gt;iindex == cd-&gt;oindex)
         || cd-&gt;lfuncs.loop_convert == wchar_id_loop_convert
         ? 1 : 0);
      <span class="enscript-keyword">return</span> 0;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">ICONV_GET_TRANSLITERATE</span>:
      *(<span class="enscript-type">int</span> *)argument = cd-&gt;transliterate;
      <span class="enscript-keyword">return</span> 0;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">ICONV_SET_TRANSLITERATE</span>:
      cd-&gt;transliterate = (*(<span class="enscript-type">const</span> <span class="enscript-type">int</span> *)argument ? 1 : 0);
      <span class="enscript-keyword">return</span> 0;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">ICONV_GET_DISCARD_ILSEQ</span>:
      *(<span class="enscript-type">int</span> *)argument = cd-&gt;discard_ilseq;
      <span class="enscript-keyword">return</span> 0;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">ICONV_SET_DISCARD_ILSEQ</span>:
      cd-&gt;discard_ilseq = (*(<span class="enscript-type">const</span> <span class="enscript-type">int</span> *)argument ? 1 : 0);
      <span class="enscript-keyword">return</span> 0;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">ICONV_SET_HOOKS</span>:
      <span class="enscript-keyword">if</span> (argument != NULL) {
        cd-&gt;hooks = *(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> iconv_hooks *)argument;
      } <span class="enscript-keyword">else</span> {
        cd-&gt;hooks.uc_hook = NULL;
        cd-&gt;hooks.wc_hook = NULL;
        cd-&gt;hooks.data = NULL;
      }
      <span class="enscript-keyword">return</span> 0;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">ICONV_SET_FALLBACKS</span>:
      <span class="enscript-keyword">if</span> (argument != NULL) {
        cd-&gt;fallbacks = *(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> iconv_fallbacks *)argument;
      } <span class="enscript-keyword">else</span> {
        cd-&gt;fallbacks.mb_to_uc_fallback = NULL;
        cd-&gt;fallbacks.uc_to_mb_fallback = NULL;
        cd-&gt;fallbacks.mb_to_wc_fallback = NULL;
        cd-&gt;fallbacks.wc_to_mb_fallback = NULL;
        cd-&gt;fallbacks.data = NULL;
      }
      <span class="enscript-keyword">return</span> 0;
    <span class="enscript-reference">default</span>:
      errno = EINVAL;
      <span class="enscript-keyword">return</span> -1;
  }
}

<span class="enscript-comment">/* An alias after its name has been converted from 'int' to 'const char*'. */</span>
<span class="enscript-type">struct</span> nalias { <span class="enscript-type">const</span> <span class="enscript-type">char</span>* name; <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> encoding_index; };

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">compare_by_index</span> (<span class="enscript-type">const</span> <span class="enscript-type">void</span> * arg1, <span class="enscript-type">const</span> <span class="enscript-type">void</span> * arg2)
{
  <span class="enscript-type">const</span> <span class="enscript-type">struct</span> nalias * alias1 = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> nalias *) arg1;
  <span class="enscript-type">const</span> <span class="enscript-type">struct</span> nalias * alias2 = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> nalias *) arg2;
  <span class="enscript-keyword">return</span> (<span class="enscript-type">int</span>)alias1-&gt;encoding_index - (<span class="enscript-type">int</span>)alias2-&gt;encoding_index;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">compare_by_name</span> (<span class="enscript-type">const</span> <span class="enscript-type">void</span> * arg1, <span class="enscript-type">const</span> <span class="enscript-type">void</span> * arg2)
{
  <span class="enscript-type">const</span> <span class="enscript-type">char</span> * name1 = *(<span class="enscript-type">const</span> <span class="enscript-type">char</span> **)arg1;
  <span class="enscript-type">const</span> <span class="enscript-type">char</span> * name2 = *(<span class="enscript-type">const</span> <span class="enscript-type">char</span> **)arg2;
  <span class="enscript-comment">/* Compare alphabetically, but put &quot;CS&quot; names at the end. */</span>
  <span class="enscript-type">int</span> sign = strcmp(name1,name2);
  <span class="enscript-keyword">if</span> (sign != 0) {
    sign = ((name1[0]==<span class="enscript-string">'C'</span> &amp;&amp; name1[1]==<span class="enscript-string">'S'</span>) - (name2[0]==<span class="enscript-string">'C'</span> &amp;&amp; name2[1]==<span class="enscript-string">'S'</span>))
           * 4 + (sign &gt;= 0 ? 1 : -1);
  }
  <span class="enscript-keyword">return</span> sign;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">iconvlist</span> (<span class="enscript-type">int</span> (*do_one) (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> namescount,
                               <span class="enscript-type">const</span> <span class="enscript-type">char</span> * <span class="enscript-type">const</span> * names,
                               <span class="enscript-type">void</span>* data),
                <span class="enscript-type">void</span>* data)
{
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">aliascount1</span>  (unsigned int)(sizeof(aliases)/sizeof(aliases[0]))
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">aliases2_lookup</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">aliascount2</span>  (unsigned int)(sizeof(sysdep_aliases)/sizeof(sysdep_aliases[0]))
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">aliascount2</span>  0
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">aliascount</span>  (aliascount1+aliascount2)
  <span class="enscript-type">struct</span> nalias aliasbuf[aliascount];
  <span class="enscript-type">const</span> <span class="enscript-type">char</span> * namesbuf[aliascount];
  <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num_aliases;
  {
    <span class="enscript-comment">/* Put all existing aliases into a buffer. */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> j;
    j = 0;
    <span class="enscript-keyword">for</span> (i = 0; i &lt; aliascount1; i++) {
      <span class="enscript-type">const</span> <span class="enscript-type">struct</span> alias * p = &amp;aliases[i];
      <span class="enscript-keyword">if</span> (p-&gt;name &gt;= 0
          &amp;&amp; p-&gt;encoding_index != ei_local_char
          &amp;&amp; p-&gt;encoding_index != ei_local_wchar_t) {
        aliasbuf[j].name = stringpool + p-&gt;name;
        aliasbuf[j].encoding_index = p-&gt;encoding_index;
        j++;
      }
    }
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">aliases2_lookup</span>
    <span class="enscript-keyword">for</span> (i = 0; i &lt; aliascount2; i++) {
      aliasbuf[j].name = stringpool2 + sysdep_aliases[i].name;
      aliasbuf[j].encoding_index = sysdep_aliases[i].encoding_index;
      j++;
    }
#<span class="enscript-reference">endif</span>
    num_aliases = j;
  }
  <span class="enscript-comment">/* Sort by encoding_index. */</span>
  <span class="enscript-keyword">if</span> (num_aliases &gt; 1)
    qsort(aliasbuf, num_aliases, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nalias), compare_by_index);
  {
    <span class="enscript-comment">/* Process all aliases with the same encoding_index together. */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> j;
    j = 0;
    <span class="enscript-keyword">while</span> (j &lt; num_aliases) {
      <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ei = aliasbuf[j].encoding_index;
      <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i = 0;
      <span class="enscript-keyword">do</span>
        namesbuf[i++] = aliasbuf[j++].name;
      <span class="enscript-keyword">while</span> (j &lt; num_aliases &amp;&amp; aliasbuf[j].encoding_index == ei);
      <span class="enscript-keyword">if</span> (i &gt; 1)
        qsort(namesbuf, i, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *), compare_by_name);
      <span class="enscript-comment">/* Call the callback. */</span>
      <span class="enscript-keyword">if</span> (do_one(i,namesbuf,data))
        <span class="enscript-keyword">break</span>;
    }
  }
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">aliascount</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">aliascount2</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">aliascount1</span>
}

<span class="enscript-comment">/*
 * Table of canonical names of encodings.
 * Instead of strings, it contains offsets into stringpool and stringpool2.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> all_canonical[] = {
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;canonical.h&quot;</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">USE_AIX</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;canonical_aix.h&quot;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">USE_OSF1</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;canonical_osf1.h&quot;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">USE_DOS</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;canonical_dos.h&quot;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">USE_EXTRA</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;canonical_extra.h&quot;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;canonical_local.h&quot;</span>
};

<span class="enscript-type">const</span> <span class="enscript-type">char</span> * <span class="enscript-function-name">iconv_canonicalize</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span> * name)
{
  <span class="enscript-type">const</span> <span class="enscript-type">char</span>* code;
  <span class="enscript-type">char</span> buf[MAX_WORD_LENGTH+10+1];
  <span class="enscript-type">const</span> <span class="enscript-type">char</span>* cp;
  <span class="enscript-type">char</span>* bp;
  <span class="enscript-type">const</span> <span class="enscript-type">struct</span> alias * ap;
  <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> count;
  <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> index;
  <span class="enscript-type">const</span> <span class="enscript-type">char</span>* pool;

  <span class="enscript-comment">/* Before calling aliases_lookup, convert the input string to upper case,
   * and check whether it's entirely ASCII (we call gperf with option &quot;-7&quot;
   * to achieve a smaller table) and non-empty. If it's not entirely ASCII,
   * or if it's too long, it is not a valid encoding name.
   */</span>
  <span class="enscript-keyword">for</span> (code = name;;) {
    <span class="enscript-comment">/* Search code in the table. */</span>
    <span class="enscript-keyword">for</span> (cp = code, bp = buf, count = MAX_WORD_LENGTH+10+1; ; cp++, bp++) {
      <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> c = * (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *) cp;
      <span class="enscript-keyword">if</span> (c &gt;= 0x80)
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid</span>;
      <span class="enscript-keyword">if</span> (c &gt;= <span class="enscript-string">'a'</span> &amp;&amp; c &lt;= <span class="enscript-string">'z'</span>)
        c -= <span class="enscript-string">'a'</span>-<span class="enscript-string">'A'</span>;
      *bp = c;
      <span class="enscript-keyword">if</span> (c == <span class="enscript-string">'\0'</span>)
        <span class="enscript-keyword">break</span>;
      <span class="enscript-keyword">if</span> (--count == 0)
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid</span>;
    }
    <span class="enscript-keyword">for</span> (;;) {
      <span class="enscript-keyword">if</span> (bp-buf &gt;= 10 &amp;&amp; memcmp(bp-10,<span class="enscript-string">&quot;//TRANSLIT&quot;</span>,10)==0) {
        bp -= 10;
        *bp = <span class="enscript-string">'\0'</span>;
        <span class="enscript-keyword">continue</span>;
      }
      <span class="enscript-keyword">if</span> (bp-buf &gt;= 8 &amp;&amp; memcmp(bp-8,<span class="enscript-string">&quot;//IGNORE&quot;</span>,8)==0) {
        bp -= 8;
        *bp = <span class="enscript-string">'\0'</span>;
        <span class="enscript-keyword">continue</span>;
      }
      <span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">if</span> (buf[0] == <span class="enscript-string">'\0'</span>) {
      code = locale_charset();
      <span class="enscript-comment">/* Avoid an endless loop that could occur when using an older version
         of localcharset.c. */</span>
      <span class="enscript-keyword">if</span> (code[0] == <span class="enscript-string">'\0'</span>)
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid</span>;
      <span class="enscript-keyword">continue</span>;
    }
    pool = stringpool;
    ap = aliases_lookup(buf,(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)(bp-buf));
    <span class="enscript-keyword">if</span> (ap == NULL) {
      pool = stringpool2;
      ap = aliases2_lookup(buf);
      <span class="enscript-keyword">if</span> (ap == NULL)
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid</span>;
    }
    <span class="enscript-keyword">if</span> (ap-&gt;encoding_index == ei_local_char) {
      code = locale_charset();
      <span class="enscript-comment">/* Avoid an endless loop that could occur when using an older version
         of localcharset.c. */</span>
      <span class="enscript-keyword">if</span> (code[0] == <span class="enscript-string">'\0'</span>)
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid</span>;
      <span class="enscript-keyword">continue</span>;
    }
    <span class="enscript-keyword">if</span> (ap-&gt;encoding_index == ei_local_wchar_t) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__STDC_ISO_10646__</span>
      <span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(wchar_t) == 4) {
        index = ei_ucs4internal;
        <span class="enscript-keyword">break</span>;
      }
      <span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(wchar_t) == 2) {
        index = ei_ucs2internal;
        <span class="enscript-keyword">break</span>;
      }
      <span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(wchar_t) == 1) {
        index = ei_iso8859_1;
        <span class="enscript-keyword">break</span>;
      }
#<span class="enscript-reference">endif</span>
    }
    index = ap-&gt;encoding_index;
    <span class="enscript-keyword">break</span>;
  }
  <span class="enscript-keyword">return</span> all_canonical[index] + pool;
 <span class="enscript-reference">invalid</span>:
  <span class="enscript-keyword">return</span> name;
}

<span class="enscript-type">int</span> _libiconv_version = _LIBICONV_VERSION;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__FreeBSD__</span> &amp;&amp; !<span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__gnu_freebsd__</span>
<span class="enscript-comment">/* GNU libiconv is the native FreeBSD iconv implementation since 2002.
   It wants to define the symbols 'iconv_open', 'iconv', 'iconv_close'.  */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">strong_alias</span>(name, aliasname) _strong_alias(name, aliasname)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">_strong_alias</span>(name, aliasname) \
  <span class="enscript-type">extern</span> __typeof (name) aliasname __attribute__ ((alias (#name)));
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">iconv_open</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">iconv</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">iconv_close</span>
<span class="enscript-function-name">strong_alias</span> (libiconv_open, iconv_open)
<span class="enscript-function-name">strong_alias</span> (libiconv, iconv)
<span class="enscript-function-name">strong_alias</span> (libiconv_close, iconv_close)
#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__APPLE__</span>
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__ppc__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>)
<span class="enscript-comment">/* backward compatibility */</span>
iconv_t
<span class="enscript-function-name">libiconv_open</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *tocode, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *fromcode)
{
	<span class="enscript-keyword">return</span> iconv_open(tocode, fromcode);
}

size_t
<span class="enscript-function-name">libiconv</span>(iconv_t cd, <span class="enscript-type">const</span> <span class="enscript-type">char</span> ** inbuf,
	size_t * inbytesleft, <span class="enscript-type">char</span> ** outbuf,
	size_t * outbytesleft)
{
	<span class="enscript-keyword">return</span> iconv(cd, (<span class="enscript-type">char</span> **)inbuf, inbytesleft, outbuf, outbytesleft);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">libiconv_close</span>(iconv_t cd)
{
	<span class="enscript-keyword">return</span> iconv_close(cd);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">libiconvctl</span>(iconv_t cd, <span class="enscript-type">int</span> request, <span class="enscript-type">void</span>* argument)
{
	<span class="enscript-keyword">return</span> iconvctl(cd, request, argument);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">libiconvlist</span>(<span class="enscript-type">int</span> (*do_one) (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> namescount,
				<span class="enscript-type">const</span> <span class="enscript-type">char</span> * <span class="enscript-type">const</span> * names,
				<span class="enscript-type">void</span>* data),
			<span class="enscript-type">void</span>* data)
{
	iconvlist(do_one, data);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __ppc__ || __i386__ */</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">endif</span>
</pre>
<hr />
</body></html>