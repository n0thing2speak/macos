<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>utf16.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">utf16.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (C) 1999-2001 Free Software Foundation, Inc.
 * This file is part of the GNU LIBICONV Library.
 *
 * The GNU LIBICONV Library is free software; you can redistribute it
 * and/or modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * The GNU LIBICONV Library is distributed in the hope that it will be
 * useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with the GNU LIBICONV Library; see the file COPYING.LIB.
 * If not, write to the Free Software Foundation, Inc., 51 Franklin Street,
 * Fifth Floor, Boston, MA 02110-1301, USA.
 */</span>

<span class="enscript-comment">/*
 * UTF-16
 */</span>

<span class="enscript-comment">/* Specification: RFC 2781 */</span>

<span class="enscript-comment">/* Here we accept FFFE/FEFF marks as endianness indicators everywhere
   in the stream, not just at the beginning. (This is contrary to what
   RFC 2781 section 3.2 specifies, but it allows concatenation of byte
   sequences to work flawlessly, while disagreeing with the RFC behaviour
   only for strings containing U+FEFF characters, which is quite rare.)
   The default is big-endian. */</span>
<span class="enscript-comment">/* The state is 0 if big-endian, 1 if little-endian. */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">utf16_mbtowc</span> (conv_t conv, ucs4_t *pwc, <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *s, size_t n)
{
  state_t state = conv-&gt;istate;
  <span class="enscript-type">int</span> count = 0;
  <span class="enscript-keyword">for</span> (; n &gt;= 2;) {
    ucs4_t wc = (state ? s[0] + (s[1] &lt;&lt; 8) : (s[0] &lt;&lt; 8) + s[1]);
    <span class="enscript-keyword">if</span> (wc == 0xfeff) {
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (wc == 0xfffe) {
      state ^= 1;
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (wc &gt;= 0xd800 &amp;&amp; wc &lt; 0xdc00) {
      <span class="enscript-keyword">if</span> (n &gt;= 4) {
        ucs4_t wc2 = (state ? s[2] + (s[3] &lt;&lt; 8) : (s[2] &lt;&lt; 8) + s[3]);
        <span class="enscript-keyword">if</span> (!(wc2 &gt;= 0xdc00 &amp;&amp; wc2 &lt; 0xe000))
          <span class="enscript-keyword">return</span> RET_ILSEQ;
        *pwc = 0x10000 + ((wc - 0xd800) &lt;&lt; 10) + (wc2 - 0xdc00);
        conv-&gt;istate = state;
        <span class="enscript-keyword">return</span> count+4;
      } <span class="enscript-keyword">else</span>
        <span class="enscript-keyword">break</span>;
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (wc &gt;= 0xdc00 &amp;&amp; wc &lt; 0xe000) {
      <span class="enscript-keyword">return</span> RET_ILSEQ;
    } <span class="enscript-keyword">else</span> {
      *pwc = wc;
      conv-&gt;istate = state;
      <span class="enscript-keyword">return</span> count+2;
    }
    s += 2; n -= 2; count += 2;
  }
  conv-&gt;istate = state;
  <span class="enscript-keyword">return</span> RET_TOOFEW(count);
}

<span class="enscript-comment">/* We output UTF-16 in big-endian order, with byte-order mark.
   See RFC 2781 section 3.3 for a rationale: Some document formats
   mandate a BOM; the file concatenation issue is not so severe as
   long as the above utf16_mbtowc function is used. */</span>
<span class="enscript-comment">/* The state is 0 at the beginning, 1 after the BOM has been written. */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">utf16_wctomb</span> (conv_t conv, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *r, ucs4_t wc, size_t n)
{
  <span class="enscript-keyword">if</span> (wc != 0xfffe &amp;&amp; !(wc &gt;= 0xd800 &amp;&amp; wc &lt; 0xe000)) {
    <span class="enscript-type">int</span> count = 0;
    <span class="enscript-keyword">if</span> (!conv-&gt;ostate) {
      <span class="enscript-keyword">if</span> (n &gt;= 2) {
        r[0] = 0xFE;
        r[1] = 0xFF;
        r += 2; n -= 2; count += 2;
      } <span class="enscript-keyword">else</span>
        <span class="enscript-keyword">return</span> RET_TOOSMALL;
    }
    <span class="enscript-keyword">if</span> (wc &lt; 0x10000) {
      <span class="enscript-keyword">if</span> (n &gt;= 2) {
        r[0] = (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>) (wc &gt;&gt; 8);
        r[1] = (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>) wc;
        conv-&gt;ostate = 1;
        <span class="enscript-keyword">return</span> count+2;
      } <span class="enscript-keyword">else</span>
        <span class="enscript-keyword">return</span> RET_TOOSMALL;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (wc &lt; 0x110000) {
      <span class="enscript-keyword">if</span> (n &gt;= 4) {
        ucs4_t wc1 = 0xd800 + ((wc - 0x10000) &gt;&gt; 10);
        ucs4_t wc2 = 0xdc00 + ((wc - 0x10000) &amp; 0x3ff);
        r[0] = (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>) (wc1 &gt;&gt; 8);
        r[1] = (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>) wc1;
        r[2] = (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>) (wc2 &gt;&gt; 8);
        r[3] = (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>) wc2;
        conv-&gt;ostate = 1;
        <span class="enscript-keyword">return</span> count+4;
      } <span class="enscript-keyword">else</span>
        <span class="enscript-keyword">return</span> RET_TOOSMALL;
    }
  }
  <span class="enscript-keyword">return</span> RET_ILUNI;
}
</pre>
<hr />
</body></html>