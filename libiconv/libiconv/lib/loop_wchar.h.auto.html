<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>loop_wchar.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">loop_wchar.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (C) 2000-2002, 2005-2006 Free Software Foundation, Inc.
 * This file is part of the GNU LIBICONV Library.
 *
 * The GNU LIBICONV Library is free software; you can redistribute it
 * and/or modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * The GNU LIBICONV Library is distributed in the hope that it will be
 * useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with the GNU LIBICONV Library; see the file COPYING.LIB.
 * If not, write to the Free Software Foundation, Inc., 51 Franklin Street,
 * Fifth Floor, Boston, MA 02110-1301, USA.
 */</span>

<span class="enscript-comment">/* This file defines three conversion loops:
     - from wchar_t to anything else,
     - from anything else to wchar_t,
     - from wchar_t to wchar_t.
 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HAVE_WCRTOMB</span> || <span class="enscript-variable-name">HAVE_MBRTOWC</span>
# <span class="enscript-reference">include</span> <span class="enscript-string">&lt;wchar.h&gt;</span>
# <span class="enscript-reference">define</span> <span class="enscript-variable-name">BUF_SIZE</span> 64  <span class="enscript-comment">/* assume MB_LEN_MAX &lt;= 64 */</span>
  <span class="enscript-comment">/* Some systems, like BeOS, have multibyte encodings but lack mbstate_t.  */</span>
  <span class="enscript-type">extern</span> size_t mbrtowc ();
# <span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">mbstate_t</span>
#  <span class="enscript-reference">define</span> <span class="enscript-function-name">mbrtowc</span>(pwc, s, n, ps) (mbrtowc)(pwc, s, n, 0)
#  <span class="enscript-reference">define</span> <span class="enscript-function-name">mbsinit</span>(ps) 1
# <span class="enscript-reference">endif</span>
# <span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">mbsinit</span>
#  <span class="enscript-reference">if</span> !<span class="enscript-variable-name">HAVE_MBSINIT</span>
#   <span class="enscript-reference">define</span> <span class="enscript-function-name">mbsinit</span>(ps) 1
#  <span class="enscript-reference">endif</span>
# <span class="enscript-reference">endif</span>
#<span class="enscript-reference">else</span>
# <span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">mbstate_t</span>
   <span class="enscript-type">typedef</span> <span class="enscript-type">int</span> mbstate_t;
# <span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * The first two conversion loops have an extended conversion descriptor.
 */</span>
<span class="enscript-type">struct</span> wchar_conv_struct {
  <span class="enscript-type">struct</span> conv_struct parent;
  mbstate_t state;
};


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HAVE_WCRTOMB</span>

<span class="enscript-comment">/* From wchar_t to anything else. */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">LIBICONV_PLUG</span>

#<span class="enscript-reference">if</span> 0

<span class="enscript-type">struct</span> wc_to_mb_fallback_locals {
  <span class="enscript-type">struct</span> wchar_conv_struct * l_wcd;
  <span class="enscript-type">char</span>* l_outbuf;
  size_t l_outbytesleft;
  <span class="enscript-type">int</span> l_errno;
};

<span class="enscript-comment">/* A callback that writes a string given in the locale encoding. */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">wc_to_mb_write_replacement</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *buf, size_t buflen,
                                        <span class="enscript-type">void</span>* callback_arg)
{
  <span class="enscript-type">struct</span> wc_to_mb_fallback_locals * plocals =
    (<span class="enscript-type">struct</span> wc_to_mb_fallback_locals *) callback_arg;
  <span class="enscript-comment">/* Do nothing if already encountered an error in a previous call. */</span>
  <span class="enscript-keyword">if</span> (plocals-&gt;l_errno == 0) {
    <span class="enscript-comment">/* Attempt to convert the passed buffer to the target encoding.
       Here we don't support characters split across multiple calls. */</span>
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>* bufptr = buf;
    size_t bufleft = buflen;
    size_t res = unicode_loop_convert(&amp;plocals-&gt;l_wcd-&gt;parent,
                                      &amp;bufptr,&amp;bufleft,
                                      &amp;plocals-&gt;l_outbuf,&amp;plocals-&gt;l_outbytesleft);
    <span class="enscript-keyword">if</span> (res == (size_t)(-1)) {
      <span class="enscript-keyword">if</span> (errno == EILSEQ || errno == EINVAL)
        <span class="enscript-comment">/* Invalid buf contents. */</span>
        plocals-&gt;l_errno = EILSEQ;
      <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (errno == E2BIG)
        <span class="enscript-comment">/* Output buffer too small. */</span>
        plocals-&gt;l_errno = E2BIG;
      <span class="enscript-keyword">else</span> 
        abort();
    } <span class="enscript-keyword">else</span> {
      <span class="enscript-comment">/* Successful conversion. */</span>
      <span class="enscript-keyword">if</span> (bufleft &gt; 0)
        abort();
    }
  }
}

#<span class="enscript-reference">else</span>

<span class="enscript-type">struct</span> wc_to_mb_fallback_locals {
  <span class="enscript-type">char</span>* l_outbuf;
  size_t l_outbytesleft;
  <span class="enscript-type">int</span> l_errno;
};

<span class="enscript-comment">/* A callback that writes a string given in the target encoding. */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">wc_to_mb_write_replacement</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *buf, size_t buflen,
                                        <span class="enscript-type">void</span>* callback_arg)
{
  <span class="enscript-type">struct</span> wc_to_mb_fallback_locals * plocals =
    (<span class="enscript-type">struct</span> wc_to_mb_fallback_locals *) callback_arg;
  <span class="enscript-comment">/* Do nothing if already encountered an error in a previous call. */</span>
  <span class="enscript-keyword">if</span> (plocals-&gt;l_errno == 0) {
    <span class="enscript-comment">/* Attempt to copy the passed buffer to the output buffer. */</span>
    <span class="enscript-keyword">if</span> (plocals-&gt;l_outbytesleft &lt; buflen)
      plocals-&gt;l_errno = E2BIG;
    <span class="enscript-keyword">else</span> {
      memcpy(plocals-&gt;l_outbuf, buf, buflen);
      plocals-&gt;l_outbuf += buflen;
      plocals-&gt;l_outbytesleft -= buflen;
    }
  }
}

#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !LIBICONV_PLUG */</span>

<span class="enscript-type">static</span> size_t <span class="enscript-function-name">wchar_from_loop_convert</span> (iconv_t icd,
                                       <span class="enscript-type">const</span> <span class="enscript-type">char</span>* * inbuf, size_t *inbytesleft,
                                       <span class="enscript-type">char</span>* * outbuf, size_t *outbytesleft)
{
  <span class="enscript-type">struct</span> wchar_conv_struct * wcd = (<span class="enscript-type">struct</span> wchar_conv_struct *) icd;
  size_t result = 0;
  <span class="enscript-keyword">while</span> (*inbytesleft &gt;= <span class="enscript-keyword">sizeof</span>(wchar_t)) {
    <span class="enscript-type">const</span> wchar_t * inptr = (<span class="enscript-type">const</span> wchar_t *) *inbuf;
    size_t inleft = *inbytesleft;
    <span class="enscript-type">char</span> buf[BUF_SIZE];
    mbstate_t state = wcd-&gt;state;
    size_t bufcount = 0;
    <span class="enscript-keyword">while</span> (inleft &gt;= <span class="enscript-keyword">sizeof</span>(wchar_t)) {
      <span class="enscript-comment">/* Convert one wchar_t to multibyte representation. */</span>
      size_t count = wcrtomb(buf+bufcount,*inptr,&amp;state);
      <span class="enscript-keyword">if</span> (count == (size_t)(-1)) {
        <span class="enscript-comment">/* Invalid input. */</span>
        <span class="enscript-keyword">if</span> (wcd-&gt;parent.discard_ilseq) {
          count = 0;
        }
        #ifndef LIBICONV_PLUG
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (wcd-&gt;parent.fallbacks.wc_to_mb_fallback != NULL) {
          <span class="enscript-comment">/* Drop the contents of buf[] accumulated so far, and instead
             pass all queued wide characters to the fallback handler. */</span>
          <span class="enscript-type">struct</span> wc_to_mb_fallback_locals locals;
          <span class="enscript-type">const</span> wchar_t * fallback_inptr;
          #<span class="enscript-keyword">if</span> 0
          locals.l_wcd = wcd;
          #endif
          locals.l_outbuf = *outbuf;
          locals.l_outbytesleft = *outbytesleft;
          locals.l_errno = 0;
          <span class="enscript-keyword">for</span> (fallback_inptr = (<span class="enscript-type">const</span> wchar_t *) *inbuf;
               fallback_inptr &lt;= inptr;
               fallback_inptr++)
            wcd-&gt;parent.fallbacks.wc_to_mb_fallback(*fallback_inptr,
                                                    wc_to_mb_write_replacement,
                                                    &amp;locals,
                                                    wcd-&gt;parent.fallbacks.data);
          <span class="enscript-keyword">if</span> (locals.l_errno != 0) {
            errno = locals.l_errno;
            <span class="enscript-keyword">return</span> -1;
          }
          wcd-&gt;state = state;
          *inbuf = (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *) (inptr + 1);
          *inbytesleft = inleft - <span class="enscript-keyword">sizeof</span>(wchar_t);
          *outbuf = locals.l_outbuf;
          *outbytesleft = locals.l_outbytesleft;
          result += 1;
          <span class="enscript-keyword">break</span>;
        }
        #endif
        <span class="enscript-keyword">else</span> {
          errno = EILSEQ;
          <span class="enscript-keyword">return</span> -1;
        }
      }
      inptr++;
      inleft -= <span class="enscript-keyword">sizeof</span>(wchar_t);
      bufcount += count;
      <span class="enscript-keyword">if</span> (count == 0) {
        <span class="enscript-comment">/* Continue, append next wchar_t. */</span>
      } <span class="enscript-keyword">else</span> {
        <span class="enscript-comment">/* Attempt to convert the accumulated multibyte representations
           to the target encoding. */</span>
        <span class="enscript-type">const</span> <span class="enscript-type">char</span>* bufptr = buf;
        size_t bufleft = bufcount;
        <span class="enscript-type">char</span>* outptr = *outbuf;
        size_t outleft = *outbytesleft;
        size_t res = unicode_loop_convert(&amp;wcd-&gt;parent,
                                          &amp;bufptr,&amp;bufleft,
                                          &amp;outptr,&amp;outleft);
        <span class="enscript-keyword">if</span> (res == (size_t)(-1)) {
          <span class="enscript-keyword">if</span> (errno == EILSEQ)
            <span class="enscript-comment">/* Invalid input. */</span>
            <span class="enscript-keyword">return</span> -1;
          <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (errno == E2BIG)
            <span class="enscript-comment">/* Output buffer too small. */</span>
            <span class="enscript-keyword">return</span> -1;
          <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (errno == EINVAL) {
            <span class="enscript-comment">/* Continue, append next wchar_t, but avoid buffer overrun. */</span>
            <span class="enscript-keyword">if</span> (bufcount + MB_CUR_MAX &gt; BUF_SIZE)
              abort();
          } <span class="enscript-keyword">else</span>
            abort();
        } <span class="enscript-keyword">else</span> {
          <span class="enscript-comment">/* Successful conversion. */</span>
          wcd-&gt;state = state;
          *inbuf = (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *) inptr;
          *inbytesleft = inleft;
          *outbuf = outptr;
          *outbytesleft = outleft;
          result += res;
          <span class="enscript-keyword">break</span>;
        }
      }
    }
  }
  <span class="enscript-keyword">return</span> result;
}

<span class="enscript-type">static</span> size_t <span class="enscript-function-name">wchar_from_loop_reset</span> (iconv_t icd,
                                     <span class="enscript-type">char</span>* * outbuf, size_t *outbytesleft)
{
  <span class="enscript-type">struct</span> wchar_conv_struct * wcd = (<span class="enscript-type">struct</span> wchar_conv_struct *) icd;
  <span class="enscript-keyword">if</span> (outbuf == NULL || *outbuf == NULL) {
    <span class="enscript-comment">/* Reset the states. */</span>
    memset(&amp;wcd-&gt;state,<span class="enscript-string">'\0'</span>,<span class="enscript-keyword">sizeof</span>(mbstate_t));
    <span class="enscript-keyword">return</span> unicode_loop_reset(&amp;wcd-&gt;parent,NULL,NULL);
  } <span class="enscript-keyword">else</span> {
    <span class="enscript-keyword">if</span> (!mbsinit(&amp;wcd-&gt;state)) {
      mbstate_t state = wcd-&gt;state;
      <span class="enscript-type">char</span> buf[BUF_SIZE];
      size_t bufcount = wcrtomb(buf,(wchar_t)0,&amp;state);
      <span class="enscript-keyword">if</span> (bufcount == (size_t)(-1) || bufcount == 0 || buf[bufcount-1] != <span class="enscript-string">'\0'</span>)
        abort();
      <span class="enscript-keyword">else</span> {
        <span class="enscript-type">const</span> <span class="enscript-type">char</span>* bufptr = buf;
        size_t bufleft = bufcount-1;
        <span class="enscript-type">char</span>* outptr = *outbuf;
        size_t outleft = *outbytesleft;
        size_t res = unicode_loop_convert(&amp;wcd-&gt;parent,
                                          &amp;bufptr,&amp;bufleft,
                                          &amp;outptr,&amp;outleft);
        <span class="enscript-keyword">if</span> (res == (size_t)(-1)) {
          <span class="enscript-keyword">if</span> (errno == E2BIG)
            <span class="enscript-keyword">return</span> -1;
          <span class="enscript-keyword">else</span>
            abort();
        } <span class="enscript-keyword">else</span> {
          res = unicode_loop_reset(&amp;wcd-&gt;parent,&amp;outptr,&amp;outleft);
          <span class="enscript-keyword">if</span> (res == (size_t)(-1))
            <span class="enscript-keyword">return</span> res;
          <span class="enscript-keyword">else</span> {
            <span class="enscript-comment">/* Successful. */</span>
            wcd-&gt;state = state;
            *outbuf = outptr;
            *outbytesleft = outleft;
            <span class="enscript-keyword">return</span> 0;
          }
        }
      }
    } <span class="enscript-keyword">else</span>
      <span class="enscript-keyword">return</span> unicode_loop_reset(&amp;wcd-&gt;parent,outbuf,outbytesleft);
  }
}

#<span class="enscript-reference">endif</span>


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HAVE_MBRTOWC</span>

<span class="enscript-comment">/* From anything else to wchar_t. */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">LIBICONV_PLUG</span>

<span class="enscript-type">struct</span> mb_to_wc_fallback_locals {
  <span class="enscript-type">char</span>* l_outbuf;
  size_t l_outbytesleft;
  <span class="enscript-type">int</span> l_errno;
};

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mb_to_wc_write_replacement</span> (<span class="enscript-type">const</span> wchar_t *buf, size_t buflen,
                                        <span class="enscript-type">void</span>* callback_arg)
{
  <span class="enscript-type">struct</span> mb_to_wc_fallback_locals * plocals =
    (<span class="enscript-type">struct</span> mb_to_wc_fallback_locals *) callback_arg;
  <span class="enscript-comment">/* Do nothing if already encountered an error in a previous call. */</span>
  <span class="enscript-keyword">if</span> (plocals-&gt;l_errno == 0) {
    <span class="enscript-comment">/* Attempt to copy the passed buffer to the output buffer. */</span>
    <span class="enscript-keyword">if</span> (plocals-&gt;l_outbytesleft &lt; <span class="enscript-keyword">sizeof</span>(wchar_t)*buflen)
      plocals-&gt;l_errno = E2BIG;
    <span class="enscript-keyword">else</span> {
      <span class="enscript-keyword">for</span> (; buflen &gt; 0; buf++, buflen--) {
        *(wchar_t*) plocals-&gt;l_outbuf = *buf;
        plocals-&gt;l_outbuf += <span class="enscript-keyword">sizeof</span>(wchar_t);
        plocals-&gt;l_outbytesleft -= <span class="enscript-keyword">sizeof</span>(wchar_t);
      }
    }
  }
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !LIBICONV_PLUG */</span>

<span class="enscript-type">static</span> size_t <span class="enscript-function-name">wchar_to_loop_convert</span> (iconv_t icd,
                                     <span class="enscript-type">const</span> <span class="enscript-type">char</span>* * inbuf, size_t *inbytesleft,
                                     <span class="enscript-type">char</span>* * outbuf, size_t *outbytesleft)
{
  <span class="enscript-type">struct</span> wchar_conv_struct * wcd = (<span class="enscript-type">struct</span> wchar_conv_struct *) icd;
  size_t result = 0;
  <span class="enscript-keyword">while</span> (*inbytesleft &gt; 0) {
    size_t incount;
    <span class="enscript-keyword">for</span> (incount = 1; incount &lt;= *inbytesleft; incount++) {
      <span class="enscript-type">char</span> buf[BUF_SIZE];
      <span class="enscript-type">const</span> <span class="enscript-type">char</span>* inptr = *inbuf;
      size_t inleft = incount;
      <span class="enscript-type">char</span>* bufptr = buf;
      size_t bufleft = BUF_SIZE;
      size_t res = unicode_loop_convert(&amp;wcd-&gt;parent,
                                        &amp;inptr,&amp;inleft,
                                        &amp;bufptr,&amp;bufleft);
      <span class="enscript-keyword">if</span> (res == (size_t)(-1)) {
        <span class="enscript-keyword">if</span> (errno == EILSEQ)
          <span class="enscript-comment">/* Invalid input. */</span>
          <span class="enscript-keyword">return</span> -1;
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (errno == EINVAL) {
          <span class="enscript-comment">/* Incomplete input. Next try with one more input byte. */</span>
        } <span class="enscript-keyword">else</span>
          <span class="enscript-comment">/* E2BIG shouldn't occur. */</span>
          abort();
      } <span class="enscript-keyword">else</span> {
        <span class="enscript-comment">/* Successful conversion. */</span>
        size_t bufcount = bufptr-buf; <span class="enscript-comment">/* = BUF_SIZE-bufleft */</span>
        mbstate_t state = wcd-&gt;state;
        wchar_t wc;
        res = mbrtowc(&amp;wc,buf,bufcount,&amp;state);
        <span class="enscript-keyword">if</span> (res == (size_t)(-2)) {
          <span class="enscript-comment">/* Next try with one more input byte. */</span>
        } <span class="enscript-keyword">else</span> {
          <span class="enscript-keyword">if</span> (res == (size_t)(-1)) {
            <span class="enscript-comment">/* Invalid input. */</span>
            <span class="enscript-keyword">if</span> (wcd-&gt;parent.discard_ilseq) {
            }
            #ifndef LIBICONV_PLUG
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (wcd-&gt;parent.fallbacks.mb_to_wc_fallback != NULL) {
              <span class="enscript-comment">/* Drop the contents of buf[] accumulated so far, and instead
                 pass all queued chars to the fallback handler. */</span>
              <span class="enscript-type">struct</span> mb_to_wc_fallback_locals locals;
              locals.l_outbuf = *outbuf;
              locals.l_outbytesleft = *outbytesleft;
              locals.l_errno = 0;
              wcd-&gt;parent.fallbacks.mb_to_wc_fallback(*inbuf, incount,
                                                      mb_to_wc_write_replacement,
                                                      &amp;locals,
                                                      wcd-&gt;parent.fallbacks.data);
              <span class="enscript-keyword">if</span> (locals.l_errno != 0) {
                errno = locals.l_errno;
                <span class="enscript-keyword">return</span> -1;
              }
              <span class="enscript-comment">/* Restoring the state is not needed because it is the initial
                 state anyway: For all known locale encodings, the multibyte
                 to wchar_t conversion doesn't have shift state, and we have
                 excluded partial accumulated characters. */</span>
              <span class="enscript-comment">/* wcd-&gt;state = state; */</span>
              *inbuf += incount;
              *inbytesleft -= incount;
              *outbuf = locals.l_outbuf;
              *outbytesleft = locals.l_outbytesleft;
              result += 1;
              <span class="enscript-keyword">break</span>;
            }
            #endif
            <span class="enscript-keyword">else</span>
              <span class="enscript-keyword">return</span> -1;
          } <span class="enscript-keyword">else</span> {
            <span class="enscript-keyword">if</span> (*outbytesleft &lt; <span class="enscript-keyword">sizeof</span>(wchar_t)) {
              errno = E2BIG;
              <span class="enscript-keyword">return</span> -1;
            }
            *(wchar_t*) *outbuf = wc;
            <span class="enscript-comment">/* Restoring the state is not needed because it is the initial
               state anyway: For all known locale encodings, the multibyte
               to wchar_t conversion doesn't have shift state, and we have
               excluded partial accumulated characters. */</span>
            <span class="enscript-comment">/* wcd-&gt;state = state; */</span>
            *outbuf += <span class="enscript-keyword">sizeof</span>(wchar_t);
            *outbytesleft -= <span class="enscript-keyword">sizeof</span>(wchar_t);
          }
          *inbuf += incount;
          *inbytesleft -= incount;
          result += res;
          <span class="enscript-keyword">break</span>;
        }
      }
    }
  }
  <span class="enscript-keyword">return</span> result;
}

<span class="enscript-type">static</span> size_t <span class="enscript-function-name">wchar_to_loop_reset</span> (iconv_t icd,
                                   <span class="enscript-type">char</span>* * outbuf, size_t *outbytesleft)
{
  <span class="enscript-type">struct</span> wchar_conv_struct * wcd = (<span class="enscript-type">struct</span> wchar_conv_struct *) icd;
  size_t res = unicode_loop_reset(&amp;wcd-&gt;parent,outbuf,outbytesleft);
  <span class="enscript-keyword">if</span> (res == (size_t)(-1))
    <span class="enscript-keyword">return</span> res;
  memset(&amp;wcd-&gt;state,0,<span class="enscript-keyword">sizeof</span>(mbstate_t));
  <span class="enscript-keyword">return</span> 0;
}

#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/* From wchar_t to wchar_t. */</span>

<span class="enscript-type">static</span> size_t <span class="enscript-function-name">wchar_id_loop_convert</span> (iconv_t icd,
                                     <span class="enscript-type">const</span> <span class="enscript-type">char</span>* * inbuf, size_t *inbytesleft,
                                     <span class="enscript-type">char</span>* * outbuf, size_t *outbytesleft)
{
  <span class="enscript-type">struct</span> conv_struct * cd = (<span class="enscript-type">struct</span> conv_struct *) icd;
  <span class="enscript-type">const</span> wchar_t* inptr = (<span class="enscript-type">const</span> wchar_t*) *inbuf;
  size_t inleft = *inbytesleft / <span class="enscript-keyword">sizeof</span>(wchar_t);
  wchar_t* outptr = (wchar_t*) *outbuf;
  size_t outleft = *outbytesleft / <span class="enscript-keyword">sizeof</span>(wchar_t);
  size_t count = (inleft &lt;= outleft ? inleft : outleft);
  <span class="enscript-keyword">if</span> (count &gt; 0) {
    *inbytesleft -= count * <span class="enscript-keyword">sizeof</span>(wchar_t);
    *outbytesleft -= count * <span class="enscript-keyword">sizeof</span>(wchar_t);
    <span class="enscript-keyword">do</span> {
      wchar_t wc = *inptr++;
      *outptr++ = wc;
      #ifndef LIBICONV_PLUG
      <span class="enscript-keyword">if</span> (cd-&gt;hooks.wc_hook)
        (*cd-&gt;hooks.wc_hook)(wc, cd-&gt;hooks.data);
      #endif
    } <span class="enscript-keyword">while</span> (--count &gt; 0);
    *inbuf = (<span class="enscript-type">const</span> <span class="enscript-type">char</span>*) inptr;
    *outbuf = (<span class="enscript-type">char</span>*) outptr;
  }
  <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> size_t <span class="enscript-function-name">wchar_id_loop_reset</span> (iconv_t icd,
                                   <span class="enscript-type">char</span>* * outbuf, size_t *outbytesleft)
{
  <span class="enscript-keyword">return</span> 0;
}
</pre>
<hr />
</body></html>