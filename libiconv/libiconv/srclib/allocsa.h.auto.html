<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>allocsa.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">allocsa.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/* Safe automatic memory allocation.
   Copyright (C) 2003-2005 Free Software Foundation, Inc.
   Written by Bruno Haible &lt;<a href="mailto:bruno@clisp.org">bruno@clisp.org</a>&gt;, 2003.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software Foundation,
   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_ALLOCSA_H</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_ALLOCSA_H</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;alloca.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stddef.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>


#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__cplusplus</span>
<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/* safe_alloca(N) is equivalent to alloca(N) when it is safe to call
   alloca(N); otherwise it returns NULL.  It either returns N bytes of
   memory allocated on the stack, that lasts until the function returns,
   or NULL.
   Use of safe_alloca should be avoided:
     - inside arguments of function calls - undefined behaviour,
     - in inline functions - the allocation may actually last until the
       calling function returns.
*/</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HAVE_ALLOCA</span>
<span class="enscript-comment">/* The OS usually guarantees only one guard page at the bottom of the stack,
   and a page size can be as small as 4096 bytes.  So we cannot safely
   allocate anything larger than 4096 bytes.  Also care for the possibility
   of a few compiler-allocated temporary stack slots.
   This must be a macro, not an inline function.  */</span>
# <span class="enscript-reference">define</span> <span class="enscript-function-name">safe_alloca</span>(N) ((N) &lt; 4032 ? alloca (N) : NULL)
#<span class="enscript-reference">else</span>
# <span class="enscript-reference">define</span> <span class="enscript-function-name">safe_alloca</span>(N) ((N), NULL)
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* allocsa(N) is a safe variant of alloca(N).  It allocates N bytes of
   memory allocated on the stack, that must be freed using freesa() before
   the function returns.  Upon failure, it returns NULL.  */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HAVE_ALLOCA</span>
# <span class="enscript-reference">define</span> <span class="enscript-function-name">allocsa</span>(N) \
  ((N) &lt; 4032 - sa_increment					    \
   ? (<span class="enscript-type">void</span> *) ((<span class="enscript-type">char</span> *) alloca ((N) + sa_increment) + sa_increment) \
   : mallocsa (N))
#<span class="enscript-reference">else</span>
# <span class="enscript-reference">define</span> <span class="enscript-function-name">allocsa</span>(N) \
  mallocsa (N)
#<span class="enscript-reference">endif</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> * <span class="enscript-function-name">mallocsa</span> (size_t n);

<span class="enscript-comment">/* Free a block of memory allocated through allocsa().  */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HAVE_ALLOCA</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">freesa</span> (<span class="enscript-type">void</span> *p);
#<span class="enscript-reference">else</span>
# <span class="enscript-reference">define</span> <span class="enscript-variable-name">freesa</span> free
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* Maybe we should also define a variant
    nallocsa (size_t n, size_t s) - behaves like allocsa (n * s)
   If this would be useful in your application. please speak up.  */</span>


#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__cplusplus</span>
}
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/* ------------------- Auxiliary, non-public definitions ------------------- */</span>

<span class="enscript-comment">/* Determine the alignment of a type at compile time.  */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__GNUC__</span>
# <span class="enscript-reference">define</span> <span class="enscript-variable-name">sa_alignof</span> __alignof__
#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__cplusplus</span>
  template &lt;class type&gt; <span class="enscript-type">struct</span> sa_alignof_helper { <span class="enscript-type">char</span> __slot1; type __slot2; };
# <span class="enscript-reference">define</span> <span class="enscript-function-name">sa_alignof</span>(type) offsetof (sa_alignof_helper&lt;type&gt;, __slot2)
#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__hpux</span>
  <span class="enscript-comment">/* Work around a HP-UX 10.20 cc bug with enums constants defined as offsetof
     values.  */</span>
# <span class="enscript-reference">define</span> <span class="enscript-function-name">sa_alignof</span>(type) (sizeof (type) &lt;= 4 ? 4 : 8)
#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">_AIX</span>
  <span class="enscript-comment">/* Work around an AIX 3.2.5 xlc bug with enums constants defined as offsetof
     values.  */</span>
# <span class="enscript-reference">define</span> <span class="enscript-function-name">sa_alignof</span>(type) 4
#<span class="enscript-reference">else</span>
# <span class="enscript-reference">define</span> <span class="enscript-function-name">sa_alignof</span>(type) offsetof (struct { char __slot1; type __slot2; }, __slot2)
#<span class="enscript-reference">endif</span>

<span class="enscript-type">enum</span>
{
<span class="enscript-comment">/* The desired alignment of memory allocations is the maximum alignment
   among all elementary types.  */</span>
  sa_alignment_long = sa_alignof (<span class="enscript-type">long</span>),
  sa_alignment_double = sa_alignof (<span class="enscript-type">double</span>),
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">HAVE_LONG_LONG</span>
  sa_alignment_longlong = sa_alignof (<span class="enscript-type">long</span> <span class="enscript-type">long</span>),
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">HAVE_LONG_DOUBLE</span>
  sa_alignment_longdouble = sa_alignof (<span class="enscript-type">long</span> <span class="enscript-type">double</span>),
#<span class="enscript-reference">endif</span>
  sa_alignment_max = ((sa_alignment_long - 1) | (sa_alignment_double - 1)
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">HAVE_LONG_LONG</span>
		      | (sa_alignment_longlong - 1)
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">HAVE_LONG_DOUBLE</span>
		      | (sa_alignment_longdouble - 1)
#<span class="enscript-reference">endif</span>
		     ) + 1,
<span class="enscript-comment">/* The increment that guarantees room for a magic word must be &gt;= sizeof (int)
   and a multiple of sa_alignment_max.  */</span>
  sa_increment = ((<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">int</span>) + sa_alignment_max - 1) / sa_alignment_max) * sa_alignment_max
};

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* _ALLOCSA_H */</span>
</pre>
<hr />
</body></html>