<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>progreloc.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">progreloc.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/* Provide relocatable programs.
   Copyright (C) 2003-2006 Free Software Foundation, Inc.
   Written by Bruno Haible &lt;<a href="mailto:bruno@clisp.org">bruno@clisp.org</a>&gt;, 2003.

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU Library General Public License as published
   by the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Library General Public
   License along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
   USA.  */</span>


#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">HAVE_CONFIG_H</span>
# <span class="enscript-reference">include</span> <span class="enscript-string">&quot;config.h&quot;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* Specification.  */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;progname.h&quot;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdbool.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;fcntl.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HAVE_UNISTD_H</span>
# <span class="enscript-reference">include</span> <span class="enscript-string">&lt;unistd.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>

<span class="enscript-comment">/* Get declaration of _NSGetExecutablePath on MacOS X 10.2 or newer.  */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HAVE_MACH_O_DYLD_H</span>
# <span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach-o/dyld.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">_WIN32</span> || <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__WIN32__</span>
# <span class="enscript-reference">define</span> <span class="enscript-variable-name">WIN32_NATIVE</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">WIN32_NATIVE</span> || <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__CYGWIN__</span>
# <span class="enscript-reference">define</span> <span class="enscript-variable-name">WIN32_LEAN_AND_MEAN</span>
# <span class="enscript-reference">include</span> <span class="enscript-string">&lt;windows.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;xreadlink.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;canonicalize.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;relocatable.h&quot;</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NO_XMALLOC</span>
# <span class="enscript-reference">define</span> <span class="enscript-variable-name">xmalloc</span> malloc
# <span class="enscript-reference">define</span> <span class="enscript-variable-name">xstrdup</span> strdup
#<span class="enscript-reference">else</span>
# <span class="enscript-reference">include</span> <span class="enscript-string">&quot;xalloc.h&quot;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* Pathname support.
   ISSLASH(C)           tests whether C is a directory separator character.
   IS_PATH_WITH_DIR(P)  tests whether P contains a directory specification.
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">_WIN32</span> || <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__WIN32__</span> || <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__CYGWIN__</span> || <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__EMX__</span> || <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__DJGPP__</span>
  <span class="enscript-comment">/* Win32, Cygwin, OS/2, DOS */</span>
# <span class="enscript-reference">define</span> <span class="enscript-function-name">ISSLASH</span>(C) ((C) == <span class="enscript-string">'/'</span> || (C) == <span class="enscript-string">'\\'</span>)
# <span class="enscript-reference">define</span> <span class="enscript-function-name">HAS_DEVICE</span>(P) \
    ((((P)[0] &gt;= <span class="enscript-string">'A'</span> &amp;&amp; (P)[0] &lt;= <span class="enscript-string">'Z'</span>) || ((P)[0] &gt;= <span class="enscript-string">'a'</span> &amp;&amp; (P)[0] &lt;= <span class="enscript-string">'z'</span>)) \
     &amp;&amp; (P)[1] == <span class="enscript-string">':'</span>)
# <span class="enscript-reference">define</span> <span class="enscript-function-name">IS_PATH_WITH_DIR</span>(P) \
    (strchr (P, <span class="enscript-string">'/'</span>) != NULL || strchr (P, <span class="enscript-string">'\\'</span>) != NULL || HAS_DEVICE (P))
# <span class="enscript-reference">define</span> <span class="enscript-function-name">FILE_SYSTEM_PREFIX_LEN</span>(P) (HAS_DEVICE (P) ? 2 : 0)
#<span class="enscript-reference">else</span>
  <span class="enscript-comment">/* Unix */</span>
# <span class="enscript-reference">define</span> <span class="enscript-function-name">ISSLASH</span>(C) ((C) == <span class="enscript-string">'/'</span>)
# <span class="enscript-reference">define</span> <span class="enscript-function-name">IS_PATH_WITH_DIR</span>(P) (strchr (P, <span class="enscript-string">'/'</span>) != NULL)
# <span class="enscript-reference">define</span> <span class="enscript-function-name">FILE_SYSTEM_PREFIX_LEN</span>(P) 0
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">set_program_name</span>


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ENABLE_RELOCATABLE</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__linux__</span>
<span class="enscript-comment">/* File descriptor of the executable.
   (Only used to verify that we find the correct executable.)  */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> executable_fd = -1;
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* Tests whether a given pathname may belong to the executable.  */</span>
<span class="enscript-type">static</span> bool
<span class="enscript-function-name">maybe_executable</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *filename)
{
  <span class="enscript-comment">/* Woe32 lacks the access() function, but Cygwin doesn't.  */</span>
#<span class="enscript-reference">if</span> !(<span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">WIN32_NATIVE</span> &amp;&amp; !<span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__CYGWIN__</span>)
  <span class="enscript-keyword">if</span> (access (filename, X_OK) &lt; 0)
    <span class="enscript-keyword">return</span> false;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__linux__</span>
  <span class="enscript-keyword">if</span> (executable_fd &gt;= 0)
    {
      <span class="enscript-comment">/* If we already have an executable_fd, check that filename points to
	 the same inode.  */</span>
      <span class="enscript-type">struct</span> stat statexe;
      <span class="enscript-type">struct</span> stat statfile;

      <span class="enscript-keyword">if</span> (fstat (executable_fd, &amp;statexe) &gt;= 0)
	{
	  <span class="enscript-keyword">if</span> (stat (filename, &amp;statfile) &lt; 0)
	    <span class="enscript-keyword">return</span> false;
	  <span class="enscript-keyword">if</span> (!(statfile.st_dev
		&amp;&amp; statfile.st_dev == statexe.st_dev
		&amp;&amp; statfile.st_ino == statexe.st_ino))
	    <span class="enscript-keyword">return</span> false;
	}
    }
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>

  <span class="enscript-keyword">return</span> true;
}

<span class="enscript-comment">/* Determine the full pathname of the current executable, freshly allocated.
   Return NULL if unknown.
   Guaranteed to work on Linux and Woe32.  Likely to work on the other
   Unixes (maybe except BeOS), under most conditions.  */</span>
<span class="enscript-type">static</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">find_executable</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *argv0)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">WIN32_NATIVE</span> || <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__CYGWIN__</span>
  <span class="enscript-type">char</span> location[MAX_PATH];
  <span class="enscript-type">int</span> length = GetModuleFileName (NULL, location, <span class="enscript-keyword">sizeof</span> (location));
  <span class="enscript-keyword">if</span> (length &lt; 0)
    <span class="enscript-keyword">return</span> NULL;
  <span class="enscript-keyword">if</span> (!IS_PATH_WITH_DIR (location))
    <span class="enscript-comment">/* Shouldn't happen.  */</span>
    <span class="enscript-keyword">return</span> NULL;
  {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__CYGWIN__</span>
    <span class="enscript-comment">/* cygwin-1.5.13 (2005-03-01) or newer would also allow a Linux-like
       implementation: readlink of &quot;/proc/self/exe&quot;.  But using the
       result of the Win32 system call is simpler and is consistent with the
       code in relocatable.c.  */</span>
    <span class="enscript-comment">/* On Cygwin, we need to convert paths coming from Win32 system calls
       to the Unix-like slashified notation.  */</span>
    <span class="enscript-type">static</span> <span class="enscript-type">char</span> location_as_posix_path[2 * MAX_PATH];
    <span class="enscript-comment">/* There's no error return defined for cygwin_conv_to_posix_path.
       See cygwin-api/func-cygwin-conv-to-posix-path.html.
       Does it overflow the buffer of expected size MAX_PATH or does it
       truncate the path?  I don't know.  Let's catch both.  */</span>
    cygwin_conv_to_posix_path (location, location_as_posix_path);
    location_as_posix_path[MAX_PATH - 1] = <span class="enscript-string">'\0'</span>;
    <span class="enscript-keyword">if</span> (strlen (location_as_posix_path) &gt;= MAX_PATH - 1)
      <span class="enscript-comment">/* A sign of buffer overflow or path truncation.  */</span>
      <span class="enscript-keyword">return</span> NULL;
    <span class="enscript-comment">/* Call canonicalize_file_name, because Cygwin supports symbolic links.  */</span>
    <span class="enscript-keyword">return</span> canonicalize_file_name (location_as_posix_path);
#<span class="enscript-reference">else</span>
    <span class="enscript-keyword">return</span> xstrdup (location);
#<span class="enscript-reference">endif</span>
  }
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* Unix &amp;&amp; !Cygwin */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__linux__</span>
  <span class="enscript-comment">/* The executable is accessible as /proc/&lt;pid&gt;/exe.  In newer Linux
     versions, also as /proc/self/exe.  Linux &gt;= 2.1 provides a symlink
     to the true pathname; older Linux versions give only device and ino,
     enclosed in brackets, which we cannot use here.  */</span>
  {
    <span class="enscript-type">char</span> *link;

    link = xreadlink (<span class="enscript-string">&quot;/proc/self/exe&quot;</span>);
    <span class="enscript-keyword">if</span> (link != NULL &amp;&amp; link[0] != <span class="enscript-string">'['</span>)
      <span class="enscript-keyword">return</span> link;
    <span class="enscript-keyword">if</span> (executable_fd &lt; 0)
      executable_fd = open (<span class="enscript-string">&quot;/proc/self/exe&quot;</span>, O_RDONLY, 0);

    {
      <span class="enscript-type">char</span> buf[6+10+5];
      sprintf (buf, <span class="enscript-string">&quot;/proc/%d/exe&quot;</span>, getpid ());
      link = xreadlink (buf);
      <span class="enscript-keyword">if</span> (link != NULL &amp;&amp; link[0] != <span class="enscript-string">'['</span>)
	<span class="enscript-keyword">return</span> link;
      <span class="enscript-keyword">if</span> (executable_fd &lt; 0)
	executable_fd = open (buf, O_RDONLY, 0);
    }
  }
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HAVE_MACH_O_DYLD_H</span> &amp;&amp; <span class="enscript-variable-name">HAVE__NSGETEXECUTABLEPATH</span>
  <span class="enscript-comment">/* On MacOS X 10.2 or newer, the function
       int _NSGetExecutablePath (char *buf, unsigned long *bufsize);
     can be used to retrieve the executable's full path.  */</span>
  <span class="enscript-type">char</span> location[4096];
  <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> length = <span class="enscript-keyword">sizeof</span> (location);
  <span class="enscript-keyword">if</span> (_NSGetExecutablePath (location, &amp;length) == 0
      &amp;&amp; location[0] == <span class="enscript-string">'/'</span>)
    <span class="enscript-keyword">return</span> canonicalize_file_name (location);
#<span class="enscript-reference">endif</span>
  <span class="enscript-comment">/* Guess the executable's full path.  We assume the executable has been
     called via execlp() or execvp() with properly set up argv[0].  The
     login(1) convention to add a '-' prefix to argv[0] is not supported.  */</span>
  {
    bool has_slash = false;
    {
      <span class="enscript-type">const</span> <span class="enscript-type">char</span> *p;
      <span class="enscript-keyword">for</span> (p = argv0; *p; p++)
	<span class="enscript-keyword">if</span> (*p == <span class="enscript-string">'/'</span>)
	  {
	    has_slash = true;
	    <span class="enscript-keyword">break</span>;
	  }
    }
    <span class="enscript-keyword">if</span> (!has_slash)
      {
	<span class="enscript-comment">/* exec searches paths without slashes in the directory list given
	   by $PATH.  */</span>
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *path = getenv (<span class="enscript-string">&quot;PATH&quot;</span>);

	<span class="enscript-keyword">if</span> (path != NULL)
	  {
	    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *p;
	    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *p_next;

	    <span class="enscript-keyword">for</span> (p = path; *p; p = p_next)
	      {
		<span class="enscript-type">const</span> <span class="enscript-type">char</span> *q;
		size_t p_len;
		<span class="enscript-type">char</span> *concat_name;

		<span class="enscript-keyword">for</span> (q = p; *q; q++)
		  <span class="enscript-keyword">if</span> (*q == <span class="enscript-string">':'</span>)
		    <span class="enscript-keyword">break</span>;
		p_len = q - p;
		p_next = (*q == <span class="enscript-string">'\0'</span> ? q : q + 1);

		<span class="enscript-comment">/* We have a path item at p, of length p_len.
		   Now concatenate the path item and argv0.  */</span>
		concat_name = (<span class="enscript-type">char</span> *) xmalloc (p_len + strlen (argv0) + 2);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NO_XMALLOC</span>
		<span class="enscript-keyword">if</span> (concat_name == NULL)
		  <span class="enscript-keyword">return</span> NULL;
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (p_len == 0)
		  <span class="enscript-comment">/* An empty PATH element designates the current directory.  */</span>
		  strcpy (concat_name, argv0);
		<span class="enscript-keyword">else</span>
		  {
		    memcpy (concat_name, p, p_len);
		    concat_name[p_len] = <span class="enscript-string">'/'</span>;
		    strcpy (concat_name + p_len + 1, argv0);
		  }
		<span class="enscript-keyword">if</span> (maybe_executable (concat_name))
		  <span class="enscript-keyword">return</span> canonicalize_file_name (concat_name);
		free (concat_name);
	      }
	  }
	<span class="enscript-comment">/* Not found in the PATH, assume the current directory.  */</span>
      }
    <span class="enscript-comment">/* exec treats paths containing slashes as relative to the current
       directory.  */</span>
    <span class="enscript-keyword">if</span> (maybe_executable (argv0))
      <span class="enscript-keyword">return</span> canonicalize_file_name (argv0);
  }
  <span class="enscript-comment">/* No way to find the executable.  */</span>
  <span class="enscript-keyword">return</span> NULL;
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">/* Full pathname of executable, or NULL.  */</span>
<span class="enscript-type">static</span> <span class="enscript-type">char</span> *executable_fullname;

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">prepare_relocate</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *orig_installprefix, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *orig_installdir,
		  <span class="enscript-type">const</span> <span class="enscript-type">char</span> *argv0)
{
  <span class="enscript-type">const</span> <span class="enscript-type">char</span> *curr_prefix;

  <span class="enscript-comment">/* Determine the full pathname of the current executable.  */</span>
  executable_fullname = find_executable (argv0);

  <span class="enscript-comment">/* Determine the current installation prefix from it.  */</span>
  curr_prefix = compute_curr_prefix (orig_installprefix, orig_installdir,
				     executable_fullname);
  <span class="enscript-keyword">if</span> (curr_prefix != NULL)
    <span class="enscript-comment">/* Now pass this prefix to all copies of the relocate.c source file.  */</span>
    set_relocation_prefix (orig_installprefix, curr_prefix);
}

<span class="enscript-comment">/* Set program_name, based on argv[0], and original installation prefix and
   directory, for relocatability.  */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">set_program_name_and_installdir</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *argv0,
				 <span class="enscript-type">const</span> <span class="enscript-type">char</span> *orig_installprefix,
				 <span class="enscript-type">const</span> <span class="enscript-type">char</span> *orig_installdir)
{
  <span class="enscript-type">const</span> <span class="enscript-type">char</span> *argv0_stripped = argv0;

  <span class="enscript-comment">/* Relocatable programs are renamed to .bin by install-reloc.  Or, more
     generally, their suffix is changed from $exeext to .bin$exeext.
     Remove the &quot;.bin&quot; here.  */</span>
  {
    size_t argv0_len = strlen (argv0);
    <span class="enscript-type">const</span> size_t exeext_len = <span class="enscript-keyword">sizeof</span> (EXEEXT) - <span class="enscript-keyword">sizeof</span> (<span class="enscript-string">&quot;&quot;</span>);
    <span class="enscript-keyword">if</span> (argv0_len &gt; 4 + exeext_len)
      <span class="enscript-keyword">if</span> (memcmp (argv0 + argv0_len - exeext_len - 4, <span class="enscript-string">&quot;.bin&quot;</span>, 4) == 0)
	{
	  <span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span> (EXEEXT) &gt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-string">&quot;&quot;</span>))
	    {
	      <span class="enscript-comment">/* Compare using an inlined copy of c_strncasecmp(), because
		 the filenames may have undergone a case conversion since
		 they were packaged.  In other words, EXEEXT may be &quot;.exe&quot;
		 on one system and &quot;.EXE&quot; on another.  */</span>
	      <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> exeext[] = EXEEXT;
	      <span class="enscript-type">const</span> <span class="enscript-type">char</span> *s1 = argv0 + argv0_len - exeext_len;
	      <span class="enscript-type">const</span> <span class="enscript-type">char</span> *s2 = exeext;
	      <span class="enscript-keyword">for</span> (; *s1 != <span class="enscript-string">'\0'</span>; s1++, s2++)
		{
		  <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> c1 = *s1;
		  <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> c2 = *s2;
		  <span class="enscript-keyword">if</span> ((c1 &gt;= <span class="enscript-string">'A'</span> &amp;&amp; c1 &lt;= <span class="enscript-string">'Z'</span> ? c1 - <span class="enscript-string">'A'</span> + <span class="enscript-string">'a'</span> : c1)
		      != (c2 &gt;= <span class="enscript-string">'A'</span> &amp;&amp; c2 &lt;= <span class="enscript-string">'Z'</span> ? c2 - <span class="enscript-string">'A'</span> + <span class="enscript-string">'a'</span> : c2))
		    <span class="enscript-keyword">goto</span> <span class="enscript-reference">done_stripping</span>;
		}
	    }
	  <span class="enscript-comment">/* Remove &quot;.bin&quot; before EXEEXT or its equivalent.  */</span>
	  {
	    <span class="enscript-type">char</span> *shorter = (<span class="enscript-type">char</span> *) xmalloc (argv0_len - 4 + 1);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NO_XMALLOC</span>
	    <span class="enscript-keyword">if</span> (shorter != NULL)
#<span class="enscript-reference">endif</span>
	      {
		memcpy (shorter, argv0, argv0_len - exeext_len - 4);
		<span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span> (EXEEXT) &gt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-string">&quot;&quot;</span>))
		  memcpy (shorter + argv0_len - exeext_len - 4,
			  argv0 + argv0_len - exeext_len - 4,
			  exeext_len);
		shorter[argv0_len - 4] = <span class="enscript-string">'\0'</span>;
		argv0_stripped = shorter;
	      }
	  }
	 <span class="enscript-reference">done_stripping</span>: ;
      }
  }

  set_program_name (argv0_stripped);

  prepare_relocate (orig_installprefix, orig_installdir, argv0);
}

<span class="enscript-comment">/* Return the full pathname of the current executable, based on the earlier
   call to set_program_name_and_installdir.  Return NULL if unknown.  */</span>
<span class="enscript-type">char</span> *
<span class="enscript-function-name">get_full_program_name</span> (<span class="enscript-type">void</span>)
{
  <span class="enscript-keyword">return</span> executable_fullname;
}

#<span class="enscript-reference">endif</span>
</pre>
<hr />
</body></html>