<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>uniq-u.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">uniq-u.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/* uniq -- remove duplicate lines from a sorted file
   Copyright (C) 86, 91, 1995-1998, 1999 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software Foundation,
   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */</span>

<span class="enscript-comment">/* Written by Richard Stallman and David MacKenzie. */</span>
<span class="enscript-comment">/* 2000-03-22  Trimmed down to the case of &quot;uniq -u&quot; by Bruno Haible. */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stddef.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>

<span class="enscript-comment">/* The name this program was run with. */</span>
<span class="enscript-type">static</span> <span class="enscript-type">char</span> *program_name;

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">xalloc_fail</span> (<span class="enscript-type">void</span>)
{
  fprintf (stderr, <span class="enscript-string">&quot;%s: virtual memory exhausted\n&quot;</span>, program_name);
  exit (1);
}

<span class="enscript-comment">/* Allocate N bytes of memory dynamically, with error checking.  */</span>

<span class="enscript-type">void</span> *
<span class="enscript-function-name">xmalloc</span> (size_t n)
{
  <span class="enscript-type">void</span> *p;

  p = malloc (n);
  <span class="enscript-keyword">if</span> (p == 0)
    xalloc_fail ();
  <span class="enscript-keyword">return</span> p;
}

<span class="enscript-comment">/* Change the size of an allocated block of memory P to N bytes,
   with error checking.
   If P is NULL, run xmalloc.  */</span>

<span class="enscript-type">void</span> *
<span class="enscript-function-name">xrealloc</span> (<span class="enscript-type">void</span> *p, size_t n)
{
  p = realloc (p, n);
  <span class="enscript-keyword">if</span> (p == 0)
    xalloc_fail ();
  <span class="enscript-keyword">return</span> p;
}

<span class="enscript-comment">/* A `struct linebuffer' holds a line of text. */</span>

<span class="enscript-type">struct</span> linebuffer
{
  size_t size;			<span class="enscript-comment">/* Allocated. */</span>
  size_t length;		<span class="enscript-comment">/* Used. */</span>
  <span class="enscript-type">char</span> *buffer;
};

<span class="enscript-comment">/* Initialize linebuffer LINEBUFFER for use. */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">initbuffer</span> (<span class="enscript-type">struct</span> linebuffer *linebuffer)
{
  linebuffer-&gt;length = 0;
  linebuffer-&gt;size = 200;
  linebuffer-&gt;buffer = (<span class="enscript-type">char</span> *) xmalloc (linebuffer-&gt;size);
}

<span class="enscript-comment">/* Read an arbitrarily long line of text from STREAM into LINEBUFFER.
   Keep the newline; append a newline if it's the last line of a file
   that ends in a non-newline character.  Do not null terminate.
   Return LINEBUFFER, except at end of file return 0.  */</span>

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> linebuffer *
<span class="enscript-function-name">readline</span> (<span class="enscript-type">struct</span> linebuffer *linebuffer, FILE *stream)
{
  <span class="enscript-type">int</span> c;
  <span class="enscript-type">char</span> *buffer = linebuffer-&gt;buffer;
  <span class="enscript-type">char</span> *p = linebuffer-&gt;buffer;
  <span class="enscript-type">char</span> *end = buffer + linebuffer-&gt;size - 1; <span class="enscript-comment">/* Sentinel. */</span>

  <span class="enscript-keyword">if</span> (feof (stream) || ferror (stream))
    <span class="enscript-keyword">return</span> 0;

  <span class="enscript-keyword">do</span>
    {
      c = getc (stream);
      <span class="enscript-keyword">if</span> (c == EOF)
	{
	  <span class="enscript-keyword">if</span> (p == buffer)
	    <span class="enscript-keyword">return</span> 0;
	  <span class="enscript-keyword">if</span> (p[-1] == <span class="enscript-string">'\n'</span>)
	    <span class="enscript-keyword">break</span>;
	  c = <span class="enscript-string">'\n'</span>;
	}
      <span class="enscript-keyword">if</span> (p == end)
	{
	  linebuffer-&gt;size *= 2;
	  buffer = (<span class="enscript-type">char</span> *) xrealloc (buffer, linebuffer-&gt;size);
	  p = p - linebuffer-&gt;buffer + buffer;
	  linebuffer-&gt;buffer = buffer;
	  end = buffer + linebuffer-&gt;size - 1;
	}
      *p++ = c;
    }
  <span class="enscript-keyword">while</span> (c != <span class="enscript-string">'\n'</span>);

  linebuffer-&gt;length = p - buffer;
  <span class="enscript-keyword">return</span> linebuffer;
}

<span class="enscript-comment">/* Free linebuffer LINEBUFFER's data. */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">freebuffer</span> (<span class="enscript-type">struct</span> linebuffer *linebuffer)
{
  free (linebuffer-&gt;buffer);
}

<span class="enscript-comment">/* Undefine, to avoid warning about redefinition on some systems.  */</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">min</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">min</span>(x, y) ((x) &lt; (y) ? (x) : (y))

<span class="enscript-comment">/* Return zero if two strings OLD and NEW match, nonzero if not.
   OLD and NEW point not to the beginnings of the lines
   but rather to the beginnings of the fields to compare.
   OLDLEN and NEWLEN are their lengths. */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">different</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *old, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *new, size_t oldlen, size_t newlen)
{
  <span class="enscript-type">int</span> order;

  order = memcmp (old, new, min (oldlen, newlen));

  <span class="enscript-keyword">if</span> (order == 0)
    <span class="enscript-keyword">return</span> oldlen - newlen;
  <span class="enscript-keyword">return</span> order;
}

<span class="enscript-comment">/* Output the line in linebuffer LINE to stream STREAM
   provided that the switches say it should be output.
   If requested, print the number of times it occurred, as well;
   LINECOUNT + 1 is the number of times that the line occurred. */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">writeline</span> (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> linebuffer *line, FILE *stream, <span class="enscript-type">int</span> linecount)
{
  <span class="enscript-keyword">if</span> (linecount == 0)
    fwrite (line-&gt;buffer, 1, line-&gt;length, stream);
}

<span class="enscript-comment">/* Process input file INFILE with output to OUTFILE.
   If either is &quot;-&quot;, use the standard I/O stream for it instead. */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">check_file</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *infile, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *outfile)
{
  FILE *istream;
  FILE *ostream;
  <span class="enscript-type">struct</span> linebuffer lb1, lb2;
  <span class="enscript-type">struct</span> linebuffer *thisline, *prevline, *exch;
  <span class="enscript-type">char</span> *prevfield, *thisfield;
  size_t prevlen, thislen;
  <span class="enscript-type">int</span> match_count = 0;

  <span class="enscript-keyword">if</span> (!strcmp (infile, <span class="enscript-string">&quot;-&quot;</span>))
    istream = stdin;
  <span class="enscript-keyword">else</span>
    istream = fopen (infile, <span class="enscript-string">&quot;r&quot;</span>);
  <span class="enscript-keyword">if</span> (istream == NULL)
    {
      fprintf (stderr, <span class="enscript-string">&quot;%s: error opening %s\n&quot;</span>, program_name, infile);
      exit (1);
    }

  <span class="enscript-keyword">if</span> (!strcmp (outfile, <span class="enscript-string">&quot;-&quot;</span>))
    ostream = stdout;
  <span class="enscript-keyword">else</span>
    ostream = fopen (outfile, <span class="enscript-string">&quot;w&quot;</span>);
  <span class="enscript-keyword">if</span> (ostream == NULL)
    {
      fprintf (stderr, <span class="enscript-string">&quot;%s: error opening %s\n&quot;</span>, program_name, outfile);
      exit (1);
    }

  thisline = &amp;lb1;
  prevline = &amp;lb2;

  initbuffer (thisline);
  initbuffer (prevline);

  <span class="enscript-keyword">if</span> (readline (prevline, istream) == 0)
    <span class="enscript-keyword">goto</span> <span class="enscript-reference">closefiles</span>;
  prevfield = prevline-&gt;buffer;
  prevlen = prevline-&gt;length;

  <span class="enscript-keyword">while</span> (!feof (istream))
    {
      <span class="enscript-type">int</span> match;
      <span class="enscript-keyword">if</span> (readline (thisline, istream) == 0)
	<span class="enscript-keyword">break</span>;
      thisfield = thisline-&gt;buffer;
      thislen = thisline-&gt;length;
      match = !different (thisfield, prevfield, thislen, prevlen);

      <span class="enscript-keyword">if</span> (match)
	++match_count;

      <span class="enscript-keyword">if</span> (!match)
	{
	  writeline (prevline, ostream, match_count);
	  exch = prevline;
	  prevline = thisline;
	  thisline = exch;
	  prevfield = thisfield;
	  prevlen = thislen;
	  <span class="enscript-keyword">if</span> (!match)
	    match_count = 0;
	}
    }

  writeline (prevline, ostream, match_count);

 <span class="enscript-reference">closefiles</span>:
  <span class="enscript-keyword">if</span> (ferror (istream) || fclose (istream) == EOF)
    {
      fprintf (stderr, <span class="enscript-string">&quot;%s: error reading %s\n&quot;</span>, program_name, infile);
      exit (1);
    }

  <span class="enscript-keyword">if</span> (ferror (ostream) || fclose (ostream) == EOF)
    {
      fprintf (stderr, <span class="enscript-string">&quot;%s: error writing %s\n&quot;</span>, program_name, outfile);
      exit (1);
    }

  freebuffer (&amp;lb1);
  freebuffer (&amp;lb2);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">main</span> (<span class="enscript-type">int</span> argc, <span class="enscript-type">char</span> **argv)
{
  <span class="enscript-type">const</span> <span class="enscript-type">char</span> *infile = <span class="enscript-string">&quot;-&quot;</span>;
  <span class="enscript-type">const</span> <span class="enscript-type">char</span> *outfile = <span class="enscript-string">&quot;-&quot;</span>;
  <span class="enscript-type">int</span> optind = 1;

  program_name = argv[0];

  <span class="enscript-keyword">if</span> (optind &lt; argc)
    infile = argv[optind++];

  <span class="enscript-keyword">if</span> (optind &lt; argc)
    outfile = argv[optind++];

  <span class="enscript-keyword">if</span> (optind &lt; argc)
    {
      fprintf (stderr, <span class="enscript-string">&quot;%s: too many arguments\n&quot;</span>, program_name);
      exit (1);
    }

  check_file (infile, outfile);

  exit (0);
}
</pre>
<hr />
</body></html>